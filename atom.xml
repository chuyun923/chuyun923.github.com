<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[楚云之南]]></title>
  <link href="http://chuyun923.github.io/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2014-12-04T16:52:25+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java中的泛型方法]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa/"/>
    <updated>2014-12-04T16:36:56+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>在通过反射获取类的私有域时希望写一个方法，可以指定一个域的名字和域的类型，可以返回指定类型的对象。</p>

<!--more-->


<p>方法实现如下：</p>

<pre><code>/**
 * 获取一个类的私有域
 * @param fromClass 私有域所在的类
 * @param toClass 私有域的类型
 * @param fieldName 域的名字
 * @param &lt;T&gt;
 * @return
 */
private &lt;T&gt; T getPrivateFiled(Class&lt;T&gt; fromClass,Class&lt;T&gt; toClass, String fieldName) {
    T result = null;
    try {
        Field field = fromClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        result = (T) field.get(this);
    } catch (NoSuchFieldException e) {
    } catch (IllegalAccessException e) {
    }
    return result;
}
</code></pre>

<p>泛型方法的结构如下：<br />
<img src="file:///Users/pengliang/Documents/java%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.png" alt="image" />
<br />
值得说明的是，声明泛型方法首先需要在返回值前面用<code>&lt;T&gt;</code>表明这是一个泛型方法，持有一个泛型。当然，一般来说我们需要在参数中传入一个class对象，不然函数的泛型没有任何意义了。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress写博客的个性配置]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/22/first/"/>
    <updated>2014-11-22T14:09:59+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/22/first</id>
    <content type="html"><![CDATA[<!--more-->


<h2>配置_config.yml</h2>

<ul>
<li>在首页只显示部分文章，而不是全文，可以通过<code>_config.yml</code>来设置，该文件中使用键值对来存储，<strong>键名: value</strong>中间的空格不能少。<code>excerpt_separator</code>，摘要标志，如果一篇文章中出现了这个标志，表明此文章在首页现实时需要采用摘要的模式，默认为<code>&lt;!--more--&gt;</code>。<code>excerpt_link</code>为读更多的link显示的文字，我们可以设置为&#8221;阅读全文&#8221;。</li>
</ul>


<h2>新建博客</h2>

<ul>
<li><p>设置使用指定的编辑器自动打开新建的blog。现在每次新建一篇blog，都要跑到<code>/source_posts</code>里面去打开，先到Rakefile文件里面的<code>## -- Misc Configs -- ##</code>注释下，在<code>server_port</code>下面新增一个键值对<code>editor = "open -a Mou"</code>。<br />
然后在文件中找到<code>new_post</code>任务，在最后一个<code>end</code>之前添加如下代码：</p>

<pre><code>  if #{editor}
      system "#{editor} #{filename}"
  end
</code></pre>

<p>如此一来，每次<code>rake new_post</code>都会自动打开Mou编辑器。</p></li>
<li><p>preview的时候自动打开浏览器预览。还是在<code>Rakefile</code>中，找到preview任务，加入代码</p>

<pre><code>  system "sleep 2; open http://localhost:#{server_port}/"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
