<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[楚云之南]]></title>
  <link href="http://chuyun923.github.io/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2015-07-14T13:58:56+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 视图树状态保存]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun/"/>
    <updated>2015-07-13T18:13:40+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun</id>
    <content type="html"><![CDATA[<h1>Android 视图树状态保存</h1>

<h2>FragmentTabHost引起的思考</h2>

<p>公司的项目是一个标准的<code>FragmentTabHost</code>与<code>Fragment</code>构成的四TAB布局。其中三个TAB中都包含有<code>ListView</code>来展现一个列表。用户在切换TAB时，<code>ListView</code>的当前位置会自动被保存，切换回来之后会自动滚动到上次的位置。</p>

<p>我们知道<code>FragmentTabHost</code>内部对于<code>Fragment</code>的切换使用的是<code>attach</code>和dettach，此时必然会走Fragment的视图树的重建，也就是在切换tab的时候，fragment的UI元素会进行重建，当然也包括重建其中的ListView。那为什么在重建之后Listview能找到正确位置？为了找到解释，我开始查阅代码。</p>

<p>第一个想法是否是我们通过Fragment的onSaveInstanceState和Bundle来保存的呢？但是看Fragment中的方法并没有任何代码进行保存，也没有进行恢复。</p>

<p>有人告诉我是通过Adapter来进行保存的，因为我们的Fragment会持有listview使用的ListAdapter，所以在重建的时候listadapter实际上复用之前的adapter，但是，通查adapter的代码，发现并没有任何保存当前位置的代码。</p>

<p>这样不科学的事情怎么会发生？一个新创建出来的ListView居然会保存之前一个ListView的状态？</p>

<h2>Android View状态保存</h2>

<p>我们经常有这样的经验，在一个EditText中我们输入一些文字，在屏幕翻转时，EditText进行重建，其中的文字还会保留(前提是你为这个EditText指定了ID)。
解释这个问题，我们需要从Android的View状态保存机制说起。</p>

<p>在View中Android定义了<code>saveHierarchyState</code>，它用来保存这个View所在的视图树的状态，传进来的参数是父view保存的状态，看到这里，你应该已经意识到了这又是android View中常用的递归伎俩。</p>

<pre><code>    public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) {
        dispatchSaveInstanceState(container);
     }

    protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
      //这里可以看到如果你不指定view的ID，系统是不会给你保存view的状态的
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        //获取当前View需要保存的Parcelable
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    "Derived class did not call super.onSaveInstanceState()");
        }
        if (state != null) {
            // Log.i("View", "Freezing #" + Integer.toHexString(mID)
            // + ": " + state);

            //妈蛋，直接是简单粗暴的 viewId ----&gt; Parcelable的映射
            container.put(mID, state);
        }
    }
}
</code></pre>

<p>从上面的代码，我们可以大致想象一下saveHierarchySate的过程，顶层的view调用saveHierarchyState,然后dispatchSaveInstanceState保存自己，为了让递归走下去，我们都能想象到在ViewGroup中的dispatchSaveInstanceState会调用子View的saveHierachySate，是不是这样呢，搂一眼ViewGroup中的代码：</p>

<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    //先把自己放到SparseArray中
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    //保存孩儿们的状态
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre>

<p>看到这里，相信你已经迫不及待想要看顶层View是在什么时机保存视图树信息的，Activity中的<code>onSaveInstanceState</code>有如下语句：</p>

<pre><code>outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
</code></pre>

<p>这里调用了跟到PhoneWindow.saveHierarchyState(),</p>

<pre><code>SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
mContentParent.saveHierarchyState(states);
</code></pre>

<p>这里交代地很清楚明白。ok，总结一下这个流程</p>

<p>Acitvity在状态需要保存时，直接new了一个SparseArray，建立movieId和Parcelable的映射，其中每一个View都会使用一个Parcelable来序列化需要保存的内容，ViewGroup在保存了自己的同时，也会去调用子类的保存状态的方法，并把上面传下来的SparseArray一直往下传。</p>

<h2>视图树状态恢复</h2>

<p><strong>视图树保存下来的SparsesArray不是被ViewGroup自己持有(避免View被重新new出来，这些信息丢失，这也是前面疑惑的根源)。</strong>以Activity为例，我们可以看到整个视图树状态保存之后会放到一个Bundle中，那我们来看看视图树是如何恢复的。</p>

<p>在Activity的<code>onRestoreInstanceState</code>中</p>

<pre><code>    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
        }
    }
</code></pre>

<p>跟到PhoneWindow中的<code>restoreHierarchyState</code></p>

<pre><code>    SparseArray&lt;Parcelable&gt; savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
</code></pre>

<p>从Bundle中拿出之前保存的SparseArray，丢给顶层View的restoreHierarchyState</p>

<pre><code>    public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) {
    dispatchRestoreInstanceState(container);
    }

    protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID) {
          //拿到当前View的id对应的Parcelable，注意，这个Parcelable很有可能是之前id相同的View保存的
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i("View", "Restoreing #" + Integer.toHexString(mID)
            // + ": " + state);
            mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(
                        "Derived class did not call super.onRestoreInstanceState()");
            }
        }
    }
    }
</code></pre>

<p>调用到View的<code>onRestoreInstanceState</code>，这里让子类去处理拿出的信息。</p>

<p>到这里，可以猜到在ViewGroup的<code>dispatchRestoreInstanceState</code>调用super方法(恢复自己)，同时应该会去恢复所有子View，这里不上代码了。</p>

<h2>回到Fragment状态保存的问题</h2>

<p>虽然<code>attach</code>和<code>dettach</code>并不会引起Activity的状态保存，但是由于视图树保存状态的机制可以知道，Fragment也可以只保留自己所持有的View，然后恢复Fragment的视图树。</p>

<p>在FragmentManager的<code>moveToState</code>方法中，调用了<code>saveFragmentViewState</code></p>

<pre><code>void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    //f.mView是Fragment的顶层View
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre>

<p> 往下走和Activity恢复视图树的过程一样鸟！</p>

<p> 这样看起来，ListView能够恢复到上次保存的位置，可以看到AbsListView中的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>进行了保存和恢复，其中保存一个变量 <code>mSyncPosition = ss.position;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python笔记]]></title>
    <link href="http://chuyun923.github.io/blog/2015/05/04/pythonbi-ji/"/>
    <updated>2015-05-04T22:05:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/05/04/pythonbi-ji</id>
    <content type="html"><![CDATA[<h2>Python语言简介</h2>

<p>Python是一种解释执行的高级脚本语言。解释执行意味着Python代码的执行需要一个类似JVM的运行环境，与JVM类似，Python也存在多个不同的解析器(运行环境)，比如我们最常用的CPython，这是一个官方版本使用C编写的解析器。</p>

<p>Python的代码有两种执行方式</p>

<ol>
<li>交互式。直接在命令行输入python，进入交互模式，退出交互模式的方法有输入 <code>exit()</code> 或者 <code>Ctrl+D</code></li>
<li>源文件。使用<code>.py</code>后缀来保存python脚本。</li>
</ol>


<h2>源文件组织行</h2>

<p>在Linux/Unix环境中，我们可以在源文件的第一行指定一个注释组织行，指定当前系统执行程序的解析器的位置。</p>

<pre><code>#!/usr/bin/python    //#!开头
</code></pre>

<p>同时，我们给文件增加 <code>x</code> 执行权限</p>

<pre><code>chmod a+x *.py
</code></pre>

<p>如此一来，我们可以直接输入文件名来执行程序，这样指定的源程序的后缀不一定要是<code>.py</code></p>

<h2>基本类型</h2>

<h3>数据类型</h3>

<ol>
<li>整数，长整数</li>
<li>浮点数</li>
<li>复数</li>
</ol>


<h3>字符串</h3>

<p>使用方法和转义字符基本上和其他语言差不多，字符串也是不可改变的。</p>

<h3>布尔值</h3>

<p>True or False  注意大小写
提供了 <code>and or not</code>运算。</p>

<h3>变量</h3>

<p>Python对于变量的命名和Java一样，但是Python和JS一样，是动态语言，即变量可以被多次赋值，而且可以每次赋值的类型不一样。</p>

<h2>语法</h2>

<h3>逻辑行和物理行</h3>

<p>物理行是你在编写程序时所看见的。逻辑行是<code>Python</code>看见的单个语句。<code>Python</code>假定每个物理行对应一个 逻辑行。如果一个逻辑行需要占用多个物理行，那么可以通过<code>\</code>来进行连接。如：</p>

<pre><code>print \
i
</code></pre>

<h3>缩进</h3>

<p>空白在python语法中占有较为重要的位置，它用来作为代码块分组的选择。</p>

<h3>运算符</h3>

<p>下面仅列出和<code>Java</code>不一样的地方</p>

<ol>
<li>** 幂  x的y次幂</li>
<li>// 整除，取整数部分</li>
<li><code>not and or</code> 对应 <code>! &amp;&amp; ||</code></li>
</ol>


<h3>if</h3>

<pre><code>if boolean:
    some code
elif boolean:   //else if
    some code
else:
    some code
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型]]></title>
    <link href="http://chuyun923.github.io/blog/2015/05/04/javafan-xing/"/>
    <updated>2015-05-04T10:14:20+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/05/04/javafan-xing</id>
    <content type="html"><![CDATA[<h1>Java基础知识点之泛型</h1>

<h2>关键词</h2>

<h2>泛型基础</h2>

<h3>神马是泛型</h3>

<p>便于程序员编写的一份代码可以用于多个类型，希望类或者方法具有通用的表达能力。</p>

<h2>泛型进阶</h2>

<h2>通配符</h2>

<h3>为什么需要</h3>

<p>例子：</p>

<pre><code>public class Parent { }
public class Child1 extends Parent { }
public class Child2 extends Parent { }

List&lt;Parent&gt; parents = new ArrayList&lt;Parent&gt;();
List&lt;Child1&gt; child1s = new ArrayList&lt;Child1&gt;();
</code></pre>

<p><code>parents</code> 和 <code>child1s</code>能相互赋值么？</p>

<pre><code>parents ＝ child1s;    //no,parents.add(child2Object)，就破坏了child1s的安全性
child1s = parents;  //no,child1s.get()有可能得到非Child1类型对象，就破坏了child1s的安全性
</code></pre>

<p>为什么有时候需要这种表达呢？考虑如下情况：</p>

<pre><code>public void printElements(List&lt;Parent&gt; elements){
    for(Parent o : elements){
        //假设，在Parent中定义了getSomeValue方法
        System.out.println(o.getSomeValue());
    }
}
</code></pre>

<p>我们需要打印所有<code>Parent</code>类型集合中的元素，但是我们不能将 <code>child1s</code>作为实参传送给<code>printElements(child1s) //inlegal</code></p>

<h3>怎么使用</h3>

<p>通配符的使用方式一共有三种：</p>

<pre><code>List&lt;?&gt;           listUknown = new ArrayList&lt;Parent&gt;();
List&lt;? extends Parent&gt; listUknown = new ArrayList&lt;Parent&gt;();
List&lt;? super  Parent&gt; listUknown = new ArrayList&lt;Parent&gt;();
</code></pre>

<p>List&lt;?>表示集合中的类型未知，但是可以确定的是它们都是一个类型，为了保证安全性，List&lt;?>只可以进行读操作。</p>

<h2>数组协变</h2>

<p>所谓协变，指的是 子类sub的数组sub[]是父类super的数组super[]的子类型。</p>

<pre><code>Object[] objs = new String[1];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Content Provider]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/16/android-provider/"/>
    <updated>2015-04-16T10:58:35+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/16/android-provider</id>
    <content type="html"><![CDATA[<p><code>ContentProvider</code>作为Android应用之间共享数据的桥梁，为共享数据提供了一个统一的访问方式(一套统一的接口)。</p>

<!--more-->


<h2>URI</h2>

<p>在Android中大量使用URI作为资源定位标识，它主要由 <code>scheme host(authority) path params组成</code>。例如我们有如下的一个<code>Content Provider</code>的URI如下：</p>

<pre><code>content://www.chuyun923.com/books/10086/title/firstWord
</code></pre>

<p>其中<code>content</code>，是Android为Content Provider规定的scheme；
PATH(<code>books/10086/title/firstWord</code>)可以直接表示用来操作的业务，表示书籍<code>_ID=10086</code>的书名的第一个单词。<strong>注意，我们可以在URI中定义各种奇葩的PATH来描述业务，但是的最终解释权归Content Provider的定义</strong></p>

<p>既然我们可以指定一些PATH表示业务，那么<code>Content Provider</code>必然需要去解析各种PATH，然后提供各种匹配的处理逻辑，此时，UriMatcher应运而生。</p>

<h3>UriMatcher</h3>

<p>对一个给定的Uri进行HOST和PATH的匹配，而Scheme不在考虑范围。对于PATH的匹配主要是挨个去比较各个PATH参数是否相等。</p>

<p>使用UriMatcher，首先需要给它配置一些配置URI，以及映射的<code>int</code>。</p>

<pre><code>    private static final UriMatcher uriMatcher;
    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("net.manoel.provider.Books", "books", 1);
        uriMatcher.addURI("net.manoel.provider.Books", "books/#/title", 2);
        uriMatcher.addURI("net.manoel.provider.Books","books/#/title/firstword",3);
    }
</code></pre>

<p>这里配置了三个业务PATH，第一个表示整个<code>books</code>整个表。第二URI表示指定Id的书名，第三个表示指定id的书名的首单词。</p>

<p>那么，
<code>books/12/title</code>将匹配第二个，在<code>Content Provider</code>收到这个<code>URI</code>时，可以使用<code>UriMatcher</code>得到2。
UriMatcher为URI提供了两种通配符 <code>#</code>代表数字；<code>*</code>代表任意字符。</p>

<p><strong>需要注意一点的是</strong>，<code>UriMatcher</code>进行匹配，会受到<code>addURI</code>的先后顺序影响。</p>

<p>如：<code>uriMatcher</code>按以下顺序添加：</p>

<pre><code>*/#
#/*
</code></pre>

<p>那么 <code>9/title</code>将不能获得匹配，是不是很奇怪？</p>

<pre><code>*/#/#
*/*/*
</code></pre>

<p> <code>books/10/title</code>也不能被匹配。</p>

<p>在匹配PATH是挨个参数进行，一旦一个路径参数被匹配，那么它就不会更换。
以<code>books/10/title</code>来说，匹配第一个patten的第一个参数 * 通过，10 匹配 <code>#</code>也通过，title不能匹配#，那么此时进行第二个patten的匹配。那么第二个patten必须满足<code>*/#</code>开头，否则就算是 <code>*/*</code>也不能通过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中日期时间API小结]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/15/"/>
    <updated>2015-04-15T17:47:06+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/</id>
    <content type="html"><![CDATA[<p>Java中为处理日期和时间提供了大量的API，确实有把一件简单的事情搞复杂的嫌疑，各种类：<code>Date Time Timestamp Calendar...</code>，但是如果能够看到时间处理的本质就可以轻松hold住这堆东西了。</p>

<!--more-->


<h2>常用的类</h2>

<h3>表示类</h3>

<ul>
<li><code>java.util.Date</code> :能够准确记录到毫秒级别的时间表示类，但是其中的各种get set(修改时间或者获取时间中某一个特殊参数)都已经被废弃。</li>
<li><code>java.sql.Date</code> :为数据库提供的日期类，继承自<code>util</code>包中的<code>Date</code>，但是这个类只能够操作日期，不能读取或者修改时间。<strong>sql和util中Date内部进行存储的long，都可以保存到毫秒级别</strong></li>
<li><code>java.sql.Time</code> :为数据库提供的时间类，和<code>Date</code>相反，它只能获取和操作时间相关的信息。</li>
<li><code>java.sql.Timestamp</code>:时间戳，继承<code>util.Date</code>，它不仅能够完美支持<code>util.Date</code>的功能，而且可以支持到纳秒级别(10^-9 s)。</li>
</ul>


<h3>工具类</h3>

<ul>
<li><code>Calendar</code>:主要用来操作一个<code>Date</code>类型，提供了一系列接口来获取或修改其中的信息。</li>
<li><code>TimeZone</code>:用来配合<code>Calendar</code> 操作<code>Date</code>，主要是考虑时区的问题，值得注意的是，在<code>Date</code>中存储的信息是一个<strong>绝对标准时间(稍后说明)</strong>，而如果需要进行时区的转化，那么只需要配合此类即可。</li>
<li><code>SimpleDateFormat</code>:常用的格式化<code>Date</code>的工具，主要是进行<code>String</code>和日期之间的互换。</li>
</ul>


<h2>基本概念</h2>

<h3>时间的来源</h3>

<p>注意，这里并不是讨论一个哲学的问题，在大部分的编程语言中，我们都是采用从1970-01-01 00:00:00.000 开始至今的毫秒差作为表示时间的数值，<strong>这个时间是绝对公立的，它和时区没有任何关系</strong>。在Java中任何时间的表示类的底层存储的毫秒数都是一个这样的标准时间。</p>

<p>在java中获取当前时间接口是<code>System.currentTimeMillis()</code>。</p>

<p>值得一提的是Java还提供了一个更加精确的时间：<code>System.nanoTime()</code>，获取一个时间精确到纳秒，但是它并不是一个当前的精确时间，而是JVM提供的一个时间，它的主要用途是来精确衡量两个时间段之间的时间，如计算一段代码的执行时间：</p>

<pre><code>    long startTime = System.nanoTime();
   // ... the code being measured ...
   long estimatedTime = System.nanoTime() - startTime;
</code></pre>

<p>可以比较两个接口返回的内容：
    <code>System.currentTimeMillis()</code>:1429108246639
    <code>System.nanoTime()</code>:1429108246640(ms)089000&mdash;&mdash;->多了6位</p>

<h3>UTC和GMT</h3>

<p>这两个标准唯一不同之处在于UTC是基于GMT进行微调之后的一个时间，本文不去深究这两者的差别，在此认为这两者是一个东西。</p>

<p>初中地理教过我们，地球是24个时区，东部和西部各12个，时区的基准点是伦敦(基准UTC)，往东，会领先UTC，往西，会落后UTC。</p>

<p>如北京属于东八区，那么我们的时间会领先基准，也就是我们在早上9点时，伦敦是早上1点。如果我们在不同时区接发邮件的时候，可以发现这个问题。</p>

<p>这个时间是我收到一份来自华盛顿的邮件的时间：</p>

<p>2014年1月23日(星期四) 晚上7:29 (UTC-05:00 华盛顿、多伦多、古巴、智利时间)</p>

<p>这里我们可以在邮件时间后面发现<code>UTC-05:00</code>，说明这里是落后UTC基准5个小时。注意，前面的时间是发件人的本地时间，如果转化成北京所在时区的时间应该是加上13h，那我收到这封邮件的本地时间是：2014-01-24 星期五早上8:29。</p>

<h3>再谈TimeStamp</h3>

<p>前面说了，TimeStamp能够精确到纳秒，那它是怎么做到的呢？由于TimeStamp继承自<code>Date</code>，它把整数秒存储在超类中，而在子类中专门用一个long类型存储零的秒数:<code>nanos</code></p>

<p>需要注意，除非你显示去调用TimeStamp的这个构造器:
<code>public Timestamp(int year, int month, int date,
                     int hour, int minute, int second, int nano)</code></p>

<p>显示去指定nano的值，否则这个构造器的参数
<code>public Timestamp(long time)</code></p>

<p>的单位实际上是毫秒。</p>

<h2>API的使用</h2>

<p>最后再来说说日期时间的操作接口，过程基本如下图：</p>

<pre><code>           SimpleDateFormat &lt;------&gt;  Date   &lt;---------&gt; Calendar
</code></pre>

<p>Date负责存储一个绝对时间，并对两边提供操作接口。Calendar负责对Date中特定信息，比如这个时间是改年的第几个星期，此外，还可以通过set,add,roll接口来进行日期时间的增减。SimpleDateFormat主要作为一些格式化的输入输出。</p>

<h3>SimpleDateFormat</h3>

<p><code>SimpleDateFormat</code>的构造器接受一个String pattern，其中的pattern是预定义的：</p>

<pre><code>G 年代标志符
y 年
M 月
d 日
h 时 在上午或下午 (1~12)
H 时 在一天中 (0~23)
m 分
s 秒
S 毫秒
E 星期
D 一年中的第几天
F 一月中第几个星期几
w 一年中第几个星期
W 一月中第几个星期
a 上午 / 下午 标记符 
k 时 在一天中 (1~24)
K 时 在上午或下午 (0~11)
z 时区
</code></pre>

<p>例子1：</p>

<pre><code> SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
            "yyyy-MM-dd E HH:mm");

    java.util.Date date = new java.util.Date();
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(date));

    //output: 2015-04-15 星期三 23:59 
    //当然，反过来，我也可以使用这个format将output的字符串转化成Date
</code></pre>

<h3>Calendar</h3>

<p>Calendar中主要需要了解的各种操作域，感觉这也是Java在做这个API时的一个败笔，灵活有余，可控性不足，初学者如果乱用域，将会产生各种bug。至于每一个域对应的时间分量，请自行google。</p>

<p>一些常用的filed：</p>

<ul>
<li>YEAR:年</li>
<li>MONTH：月（从0 开始，0 表示1月&hellip;.11表示12月）</li>
<li>DAY_OF_MONTH :几号（等同DATE）</li>
<li>DAY_OF_WEEK：星期几</li>
<li>DAY_OF_YEAR：年里面的天</li>
<li>DATE:几号（等同DAY_OF_MONTH）</li>
</ul>


<p>一个filed通常来说对应了日期时间中的某一个分量，在操作这个分类有些操作会向高位进位，而有的操作则不会【<strong>bug高发区域</strong>】。</p>

<p>例子2：</p>

<pre><code>SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
     "yyyy-MM-dd E");
    Calendar calendarT = Calendar.getInstance(Locale.CHINA);
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.MONTH,12);// 月份进位
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    //output:   2015-04-16 星期四
                    2016-01-16 星期六
</code></pre>

<p>例子3：</p>

<pre><code>        SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
     "yyyy-MM-dd E");
    Calendar calendarT = Calendar.getInstance(Locale.CHINA);
    System.out.println("原始    :"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.DAY_OF_MONTH,1);// 当月第一天
    System.out.println("当月第一天:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    //roll不会进位
    calendarT.roll(Calendar.DATE,-1);
    System.out.println("roll -1:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.DAY_OF_MONTH,1);// 当月第一天
    calendarT.add(Calendar.DATE,-1);
    //add产生进位
    System.out.println("add -1:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));

    //output:原始    :2015-04-16 星期四
                当月第一天:2015-04-01 星期三
                roll -1:2015-04-30 星期四
                add -1:2015-03-31 星期二
</code></pre>

<p>最后还是需要说明一点，获取当前时间指的是当前本地时间对应的UTC时间，和时区没有关系！有点绕，没关系看代码：</p>

<p>例子4：</p>

<pre><code>Calendar calendar1 = Calendar.getInstance(Locale.CHINA);
    Calendar calendar2 = Calendar.getInstance(Locale.GERMAN);
    System.out.println(calendar1.getTimeInMillis());
    System.out.println(calendar2.getTimeInMillis());

    //output:
        1429115150117
        1429115150117
</code></pre>

<p>最后贴一个日期处理开源库：<a href="https://github.com/JodaOrg/joda-time"><strong>joda-time</strong></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle指南-11]]></title>
    <link href="http://chuyun923.github.io/blog/2015/02/05/gradlezhi-nan-11/"/>
    <updated>2015-02-05T00:55:29+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/02/05/gradlezhi-nan-11</id>
    <content type="html"><![CDATA[<h1>使用命令行执行gradle任务</h1>

<p><a href="http://gradle.org/docs/current/userguide/tutorial_gradle_command_line.html">指南原文，看这里</a></p>

<p>gradle执行task的基本命令是：</p>

<p><code>gradle taskname</code></p>

<p><strong>gradle支持模糊匹配，taskname只要能够模糊唯一匹配即可</strong></p>

<h2>gradle执行多个task</h2>

<p>命令格式： <code>gradle task1 task2 ...</code></p>

<p>这样可以按顺序执行task1，task2，以及这些task所依赖的task,一个task及其依赖执行完了，才会执行下一个task。task依赖最深的会被最先执行然后递归出来。<strong>每一个task不管被依赖了几次，在一条gradle命令时，都只执行一次。</strong></p>

<p>例有四个task的依赖如下图：</p>

<p><img src="http://gradle.org/docs/current/userguide/img/commandLineTutorialTasks.png" alt="" /></p>

<p>执行<code>gradle dist test</code>，首先会执行<code>dist</code>的依赖，所以执行顺序为：
compile&ndash;>compileTest&ndash;>test&ndash;>dist(每个task都只执行一遍)</p>

<h2>排除task</h2>

<p>如果不想执行某个task(一般是task依赖的task)，可以通过：</p>

<p><code>gradle task1 task2 -x excludingTask1,excludingTask2..</code>，去掉的task以及它所带入的依赖task都不会被执行。</p>

<h2>gradle tasks&hellip; &ndash;continue</h2>

<p>如果不加，那么gradle在执行task的时候，如果遇到错误，那么以下所有没有执行的task都会终止，这一次build结束。加上continue参数之后，每一次gradle命令都会执行所有的task，这样可以检查所有的task。
<strong>如果一个task失败，那么所有基于这个task的task都不会被执行。</strong></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码(二)之JsonReader和JsonWriter]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li/"/>
    <updated>2015-01-10T14:17:21+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li</id>
    <content type="html"><![CDATA[<p>前文介绍了<code>Gson</code>对于<code>Json</code>规范中的类型进行了抽象定义，本文将来介绍<code>stream</code>包中的源码，这一块是<code>Gson</code>的核心代码之一。Gson中的JsonReader和JsonWriter抄自android.util包中的两个类，只是把其中的上下文栈由ArrayList换成了数组，提高了效率。这两个类为Json序列化和反序列化提供了基本接口。</p>

<!--more-->


<h1>反序列化&mdash;JsonReader</h1>

<h2>StringPool&ndash;(Flyweight Pattern)</h2>

<p>在Stream包中提供了一种针对String的优化处理，可以减少内存中String对象的个数，途径就是通过StringPool来对字符串进行复用。需要注意的是，在Java中字符串对象是不能被修改的，这也是这个Pool能正常工作的重要原因。StringPool原理和HashMap一模一样，通过一个2的n次方(512)作为数组的长度，字符串的hascode计算方式和String中的一致。为了使得hashcode分布分散一点，同样使用hashmap的补偿hash函数对hashcode进行处理，这一块的具体优化处理可以关注以后的HashMap源码分析。</p>

<h2>深度优先的解析策略</h2>

<p>Gson解析Json字符采用的是深度优先策略，下面是一个简单解析的栗子：</p>

<pre><code>[
&lt;!--数组中每一个对象为一个message对象--&gt;
{
  "id": 912345678901,
  "text": "How do I read a JSON stream in Java?",
  &lt;!--geo是一个double类型的数组--&gt;
  "geo": null,
  &lt;!--user对象--&gt;
  "user": {
    "name": "json_newb",
    "followers_count": 41
   }
},
{
  "id": 912345678902,
  "text": "@json_newb just use JsonReader!",
  "geo": [50.454722, -104.606667],
  "user": {
    "name": "jesse",
    "followers_count": 2
  }
}
]
</code></pre>

<p>深度解析的逻辑如下，先找到这个json字符串的开始位置，本例中是<code>[</code>，此时我们知道这个json字符串是一个数组，下一步从第一个元素开始解析(一层循环)。读取下一个字符，<code>{</code>,可以知道第一个元素为对象。对于<code>{</code>开始的JsonObject，我们知道它其中的内容肯定是键值对的样式，那我可以读取下一个字符，而且它必须为<code>"</code>(属性名)，然后去读取属性值。ok，我们可以看到这是一种非常正常的解析逻辑，其实Gson的解析就是这么做的。</p>

<h2>数据抽象</h2>

<p>为了进行上面的解析过程，Gson中定义了两种数据类型：</p>

<h3>JsonToken(解析类型)</h3>

<p>由于Json定义规范的原因，我们在解析过程中只要解析到一个结构的第一个元素再联系上下文就可以推断这个结构的类型。JsonToken用来描述<code>Json</code>中的<code>'{','}','[',']','"'</code>,<code>NULL</code>,<code>number</code>，<code>boolean</code>,属性名和属性字符串值，其实JsonToken的基本上等于每一个结构的开头，其中<code>"</code>既可以表示一个属性名也可以表示一个属性就是一个String，这需要按照上下文来确定。
在<code>JsonReader</code>定义了一个属性<code>token</code>，用来存储<code>Json</code>串解析位置的下一个<code>JsonToken</code>。</p>

<h3>JsonScope(解析上下文)</h3>

<p>用来描述当前正在解析的位置所处的一个状态，为解析提供一个上下文做推断。比如，目前我们解析到了一个<code>{</code>字符，那么下一个字符串必须是空或者&#8217;&ldquo;&lsquo;，如此我们可以推断这个<code>"</code>肯定是一个JsonToken.Name(属性名)。此外，JsonScope还可以描述一个JsonArray或者JsonObject目前解析到的位置是否是第一个元素。<code>JsonScope</code>被存放在一个栈中，而且是成对出现。</p>

<pre><code> private JsonScope[] stack = new JsonScope[32];
 {
   push(JsonScope.EMPTY_DOCUMENT);  //静态初始化时push空Json文件到栈顶
 }
 需要注意的是，这里这个栈之只实现了一个push操作，并提供了动态增长，出栈操作只需要简单的简单的stacksize--
</code></pre>

<h2>JsonReader工作流</h2>

<p><code>JsonReader</code>的构造函数接受一个<code>Reader</code>的参数，它是一个<code>Json</code>串的<code>InputStream</code>包装出来的<code>Reader</code>。</p>

<p>对于这个上文<code>Json</code>文档的解析，<code>JsonReader</code>的理逻辑如下：</p>

<pre><code>List&lt;Message&gt; result = new ArrayList&lt;Message&gt;(); 
jsonReader.beginArray();   //找到数组
while(jsonReader.hasnext) {
    Message message = new Message();
    jsonReader.beginObject();   //开始数组中的对象
    while(jsonReader.hasnext) {
        String name = jsonReader.nextName();
        if(name.equals("id")) {
            message.setId(jsonReader.nextString());
        }else if(name.equals("text")) {
            message.setText(jsonReader.nextString());
        }else if(name.equals("geo")&amp;&amp;jsonReader.peek()!=NULL) {
             List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();
             jsonReader.beginArray();
             while(jsonReader.hasnext()) {
                list.add(jsonReader.nextDouble());
             }
             JsonReader.endArray();
        }
        jsonReader.beginObject();
       .....开始解析User对象......
    }
    result.add(message);
}
</code></pre>

<h3>一些函数的解释</h3>

<h4>begin和 end系列函数</h4>

<p>其实这两个函数只是从业务的角度出发，封装了一下，实际两个函数都是调用<code>except(JsonToken)</code>，作用是寻找<code>json</code>字符串中的下一个<code>JsonToken</code>。以<code>beginObject()</code>函数来说，它直接调用<code>except(JsonToken.BEGIN_OBJECT)</code>。</p>

<pre><code>private void expect(JsonToken expected) throws IOException {
peek();         //找到下一个JsonToken，赋值给JsonReader的token属性
if (token != expected) {  //判断下一个Token是否等于指定的Token类型
  throw new IllegalStateException("Expected " + expected + " but was " +        peek() + " at line " + getLineNumber() + " column " +       getColumnNumber());
}
advance();  //下一步操作
}
</code></pre>

<h4>peek函数</h4>

<p>peek函数是JsonReader中最重要的函数，它的主要作用是进行上下文的判断，判断下一个JsonToken的读取方法。</p>

<p>下面看一下<code>peek()</code>函数的实现：</p>

<pre><code>public JsonToken peek() throws IOException {
//之前解析出来的token还没有被消费，直接取回
if (token != null) {
  return token;
}
//查看栈顶的JsonScope，这里可以看到JsonScope就是一个上下文的角色
switch (stack[stackSize - 1]) {
case EMPTY_DOCUMENT:    //json文档的开始 
  if (lenient) {    //json防止攻击引入的前导，防止跨域攻击
    consumeNonExecutePrefix();
  }
  stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;   //注意这里不是push而是直接替换栈顶元素
  JsonToken firstToken = nextValue();   //返回流中的下一个开始JsonToken，在上个例子中就是'['，也就是这里返回的是一个JsonToken.BEGIN_ARRAY,这个值还会被保存在token属性中
  if (!lenient &amp;&amp; token != JsonToken.BEGIN_ARRAY &amp;&amp; token != JsonToken.BEGIN_OBJECT) {   //一个json文档开始无非就是一个对象或者数组
    throw new IOException("Expected JSON document to start with '[' or '{' but was " + token
        + " at line " + getLineNumber() + " column " + getColumnNumber());
  }
  return firstToken;
case EMPTY_ARRAY:
    //目前处于一个数组中，但是还没有开始读取任何数据
  return nextInArray(true);
case NONEMPTY_ARRAY:
  return nextInArray(false);
case EMPTY_OBJECT: //目前处于一个JsonObject中但是还没有读取任何数据
  return nextInObject(true);
case DANGLING_NAME: //目前处于一个属性名的位置
  return objectValue();
case NONEMPTY_OBJECT:
  return nextInObject(false);
case NONEMPTY_DOCUMENT:
    //当前处于一个文档的解析上下文中，可以理解为根元素下一级的环境
  int c = nextNonWhitespace(false);
  if (c == -1) {
    return JsonToken.END_DOCUMENT;
  }
  pos--;
  if (!lenient) {
    throw syntaxError("Expected EOF");
  }
  //找下一个JsonToken
  return nextValue();
case CLOSED:
  throw new IllegalStateException("JsonReader is closed");
default:
  throw new AssertionError();
}
}
</code></pre>

<h4>nextIn**()</h4>

<p> 提供了数组、JsonObject的解析方法。</p>

<h4>nextValue()</h4>

<pre><code>找下一个JsonToken

private JsonToken nextValue() throws IOException {
int c = nextNonWhitespace(true);    //找到当前解析位置之后的第一个非空白字符
switch (c) {
case '{':
  push(JsonScope.EMPTY_OBJECT);   //进入一个JsonObject
  return token = JsonToken.BEGIN_OBJECT;

case '[':
  push(JsonScope.EMPTY_ARRAY);   //进入一个数组
  return token = JsonToken.BEGIN_ARRAY;
  //以上两种情况说明是一个新的结构的开始，所以需要pushJsonScope到栈中
case '\'':
  checkLenient(); // fall-through
case '"':
  //代表一个Json字符串值
  value = nextString((char) c);  //找到两个引号之间的String值
  return token = JsonToken.STRING;

default:
  pos--;
  return readLiteral();
}
}
</code></pre>

<h3>JsonReader总结</h3>

<p>JsonReader可以看作一个最基本的Json解析的接口，JsonReader中通过一个上下文来保存当前解析的环境，通过next**系列函数来获取下一个JsonToken。</p>

<h1>序列化&ndash;JsonWriter</h1>

<p>理解了JsonReader的源码之后，再来看Writer就相对来说简单多了。现在我们有一个数组，List<Message>，它的值就如上面的例子，那如何序列化呢?</p>

<pre><code>public void writeJsonStream(OutputStream out, List&lt;Message&gt; messages) throws IOException {
      JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
      writer.setIndent("\t");           //设置每一行的缩进
      writeMessagesArray(writer, messages);
      writer.close();
    }

    public void writeMessagesArray(JsonWriter writer, List&lt;Message&gt; messages) throws IOException {
      writer.beginArray();   //[
      for (Message message : messages) {
        writeMessage(writer, message);
      }
      writer.endArray();
    }

    public void writeMessage(JsonWriter writer, Message message) throws IOException {
      writer.beginObject(); //{
      writer.name("id").value(message.getId()); // "id":23435356
      writer.name("text").value(message.getText()); //"text":"dflsfldsfljd"
      if (message.getGeo() != null) {
        writer.name("geo");
        writeDoublesArray(writer, message.getGeo());
      } else {
        writer.name("geo").nullValue();
      }
      writer.name("user");
      writeUser(writer, message.getUser());
      writer.endObject();
    }

    public void writeUser(JsonWriter writer, User user) throws IOException {
      writer.beginObject();
      writer.name("name").value(user.getName());
      writer.name("followers_count").value(user.getFollowersCount());
      writer.endObject();
    }

    public void writeDoublesArray(JsonWriter writer, List&lt;Double&gt; doubles) throws IOException {
      writer.beginArray();
      for (Double value : doubles) {
        writer.value(value);
      }
      writer.endArray();
    }
</code></pre>

<h2>JsonWriter中的函数</h2>

<p>   事实上，可以看到JsonWriter的工作和JsonReader刚好相反，两个类的对json字符串的处理方式也基本相同。下面说一些业务流程中较为重要的方法。</p>

<h3>beginArray and beginObject</h3>

<p>开始向流中写入一个数组或者JsonObject的开始，注意，这里不仅仅是写入一个<code>[</code>或者一个<code>{</code>这么简单，首先会调用<code>writeDeferredName</code>方法，它的主要功能是如果这个开始的JsonElement是JsonObject中的一个属性，那么它的前面肯定有一个和上一个元素的分割符号和一个名字。</p>

<h3>endArray and endObject</h3>

<p>结束一个数组和对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMa效率分析]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/09/hashmaxiao-lu-fen-xi/"/>
    <updated>2015-01-09T11:00:58+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/09/hashmaxiao-lu-fen-xi</id>
    <content type="html"><![CDATA[<p>先填个link到这里吧：<a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function">http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function</a></p>

<p><a href="http://pengranxiang.iteye.com/blog/543893">http://pengranxiang.iteye.com/blog/543893</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码分析(一)之Json结构抽象和注解使用]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi/"/>
    <updated>2015-01-06T22:31:27+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<p>XML和Json作为最常用的两种网络传输格式而被广泛使用，XML在早期数据传输中作为首选，但是近年来Json以其轻量级和更容易编写和解析而越来越流行，Gson作为google的一个开源Json解析框架提供了稳定和快速解析的功能，可以读读它的源代码了解一番。</p>

<!--more-->


<p>说到Gson，其实它无非就是做两个工作，序列化(Object&mdash;>JsonString)和反序列化(JsonString&mdash;>Object)，后文所说的<em>两个方向</em>从Object到String和String到Object的两个方向。可想而知，对于序列化来说，是较为容易的工作，而对于反序列化即Json解析才是Gson的重头戏。既然是对Json字符串的解析，那么少不了对Json字符串中的结构进行抽象。</p>

<h2>Json抽象类</h2>

<h3>JsonElement</h3>

<p>这是Json中元素的基类，它只提供了若干个类型判断的接口，简单判断这个Json元素的类型。以下几个类型都是它的子类。</p>

<h4>1、JsonObject</h4>

<p>包含多个JsonElement的集合，它在Json中对应这种类型的数据：</p>

<pre><code>{
    "count":100,
    "users":[],
    "paging":{
        "offset":0,
        "limit":10,
        "hasMore":true
    }
}
</code></pre>

<p>这个data是一个典型的JsonObject，它以<code>{</code>开头，其中包含了一些类似数值，数组，对象等其他JsonElement的内容。<strong>其实每一个Json字符串的根节点都是一个JsonObject或者JsonArray。</strong></p>

<p>JsonObject提供了比较多的方法来得到Json中的信息，addProperty()函数可以在当前Json节点下新建子结点。</p>

<h4>2、JsonArray</h4>

<p>JsonArray也表示JsonElement的集合，注意：<strong>Json中的数组并不要求所有的数据类型都一样</strong>。</p>

<pre><code>    [true,"hello"] //JsonArray,包括一个boolean和一个hello类型。
</code></pre>

<p>需要讨论的是JsonArray和JsonObject的区别是什么？从集合的角度来说，JsonObject中的JsonElement是无序的，而JsonArray中的集合元素是有序的，从直观感受来说，你可以通过下标来引用JsonArray中的元素，而JsonObject是通过键值对的方式来访问的,<code>get("name")---&gt;value</code>。</p>

<h4>3、JsonPrimitive</h4>

<p>对应Json中的基本类型，比如boolean，int，当然提供了基本类型和包装类的自动替换。</p>

<pre><code>"count":100
</code></pre>

<h4>4、JsonNull</h4>

<p>空，对应null</p>

<pre><code>"person":null
</code></pre>

<p>以上就是Gson对应Json结构的封装。</p>

<h3>注解-Annotations</h3>

<h4>Expose</h4>

<p>在对象进行序列化和反序列化的过程中，我们可以通过注解来屏蔽某一些字段。这个注解默认有两个参数，<code>serialize</code>和<code>deserialize</code>都是默认true。如果设置为false，表示这个序列化(反)的过程中，这一个属性不需要进行处理。</p>

<p>通过Expose标注的属性在直接<code>new Gson()</code>的情况下不能生效，我们必须通过<code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>来创建一个可以识别Expose注解的Gson。</p>

<p>小小的吐槽一把，这个地方的使用确实不太方便，举个栗子，一般来说，我们进行序列化的时候都是希望某一个属性不会序列化到Json字符里面(反之亦然)，所以这里的一般思维是我要去处理这些特殊的属性。而如果你想通过Expose来去掉10个属性中的某一个，对不起，10个属性你都需要加上<code>@Expose</code>,然后对你想要处理的那个属性的Expose注解增加false参数，简直就是坑爹。。。。</p>

<pre><code>//我想让Person类在序列化时，不去序列化password，是不是很坑爹？
class Person {
    @Expose
    private String userName;
    @Expose (serialize = false)
    private String passWord;
}
</code></pre>

<p>此外，和java本身的序列化一样，如果一个属性设置为<code>transient</code>或者<code>static</code>,那么两个序列化的两个方向上都会屏蔽掉这个属性，虽然比Expose简单，但是不够灵活。</p>

<h4>SerializedName</h4>

<p>这个注解使用较多，它会改变两个方向上这个属性的名称，在序列化是，JsonElement的键值会被替换成这个名字；解析时，Json中键值为这个名字的JsonElement会赋值给被注解的属性。</p>

<pre><code>class Person {

@SerializedName(value = "A")
private int a ＝ 1;
private int b = 2;
}

//{"A":1,"b":2}  这个Json字符串和前面的Person等价
</code></pre>

<p>它使用场景最多的地方就是比如后端返回的json中的名称和我们定义的model类名称不一样时使用。</p>

<h4>Since 和 Until</h4>

<p>我们可以对我们的Model类进行序列化(两个方向)的版本控制，Since和Until刚好是两个相反的意义。</p>

<p>例子：</p>

<pre><code>class Person {
    @Since(value = 1.0)     //GsonBuilder指定版本要从1.0开始的Gson才能解析
    private int a = 1;

    @Until(value = 1.5)   //GsonBuilder指定版本到1.5的Gson都可以解析，超过了不能解析
    private int b = 2;
}
</code></pre>

<p>和Expose一样，要想Gson识别这两个注解，同样需要通过GsonBuilder.setVersion(double).create()来实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ActionBar]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/23/android-actionbar/"/>
    <updated>2014-12-23T10:58:00+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/23/android-actionbar</id>
    <content type="html"><![CDATA[<p>ActionBar作为Android3.0系统引入的一个重要的android app的风格，了解它的使用方法是每一个android开发者都必须要掌握的，本文主要基于android官方文档，对一些不常用的内容进行了删减，整理而成。</p>

<!--more-->


<p>说起3.0以后的ActionBar，其实在做3.0以前开发的童鞋应该有印象，Android提供了一个TitleBar，只不过默认的TitleBar只能显示一个标题和一个图标。它的样子大概如下：<br />
<img src="http://androidpeople.files.wordpress.com/2009/12/withicon.jpg" alt="" /></p>

<p>如果需要自己定义一个更加炫酷的Titlebar,比较麻烦，可以参考这篇文章：<a href="http://www.cnblogs.com/a284628487/archive/2013/06/07/3125265.html"><strong>自定义TitleBar</strong></a></p>

<p>ActionBar是TitleBar的增强版本，主要包括四个部分：</p>

<ol>
<li>为app提供一个唯一图片标识和导航的button,如果当前页面不是应用的首页，应该在app icon的左边添加返回的剪头。</li>
<li>切换界面上显示的view，官方名称叫view control。</li>
<li>放置一些显式的按钮，长按会显示它的title</li>
<li>放置一个action overflow</li>
</ol>


<p>对应如下图片：</p>

<p><img src="https://developer.android.com/design/media/action_bar_basics.png" alt="" /></p>

<p>正常的ActionBar会占据一定的屏幕空间，在ActionBar显示或者隐藏时，屏幕中的数据都会重绘去适应。如果我们需要ActionBar浮动在内容上面，可以将<code>windowActionBarOverlay</code>属性设置为true。</p>

<h2>增加ActionBar的Item</h2>

<p>在android菜单中曾经提到如何在ActionBar中增加菜单项，这里不再赘述。这里补充一个小的case：</p>

<p> 在ActionBar上显示的item也可以同时显示icon和title，当然前提是ActionBar的空间富余。通过在showAsAction中增加withText。</p>

<h2>分离的ActionBar(split)</h2>

<p>在分辨率不大的设备上，如果有足够多的Item需要显示，可能面临着屏幕宽度不够而显示不了那么多的Icon。分离ActionBar中的logo和菜单项，将菜单项移动到屏幕的下面，如图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-splitaction@2x.png" alt="" /></p>

<p>如果需要系统处理，那么我们需要指定属性：<code>uiOptions="splitActionBarWhenNarrow"</code>，但是如果需要支持低版本，我们可以这样写：</p>

<pre><code>    &lt;manifest ...&gt;
        &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
            &lt;meta-data android:name="android.support.UI_OPTIONS"
               android:value="splitActionBarWhenNarrow" /&gt;
        &lt;/activity&gt;
    &lt;/manifest&gt;
</code></pre>

<h2>ActionBar的导航button</h2>

<p>如果设置ActionBar.setDisplayHomeAsUpEnable(true),会产生一个导航按钮，如图所示：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-up.png" alt="" /></p>

<p>这个按钮和系统的back按键的区别在于，系统的back键有时候仅仅是为了返回到屏幕的上一次状态，而点击这个导航键就会返回到上一次的界面。
如果仅仅set这个导航键可见，它并不会响应任何操作，我们需要手动去指定点击这个导航键将会打开那个Activity，有两种方法可以来指定：</p>

<ol>
<li>在Menifest文件中通过activity的parentActivityname属性指定，当然这个属性是4.1加入的，如果要兼容之前的版本，可以通过meta的方式来做到。</li>
<li>在Activity中复写getParentActivityIntent，可以指定在app内导航的Intent。在别的应用中打开app，可以通过复写onCreateNavigateUpTaskStack来实现。</li>
</ol>


<p>注意，在support v7包中的actionbarActivity中，对以上提供了默认实现。</p>

<h2>ActionView</h2>

<p>actionview是在点击action button之后，一个显示出来的交互view,如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-searchview@2x.png" alt="" /></p>

<p>可以通过Menu item的<code>actionViewClass</code>来指定一个widget。我们也可以直接自己指定一个自定义布局给Action button，只需要把layout的id赋值给<code>actionLayout</code>即可。</p>

<p>app要获取这个Action View中的一些事件，可以在onCreateOptionsMenu中通过<code>menuItem.getActionView()</code>来获得。</p>

<p>下面来说一个比较有意思的可折叠的actionview，前文可知，如果设置actionLayout，那么如果ActionBar上面空间足够时，会直接把这个自定义的layout显示出来，但是如果这个item被放到overflow里面去了呢？此时<code>showAction</code>中的一个属性<code>collapseActionView</code>的作用就会显示出来，这个属性的作用是：</p>

<p>如果这个action button被放到overflow中，点击后还是可以把它的actionview打开(可折叠)，如果不加这个属性，那么系统将不会打开actionview。如果是打开折叠的actionview，ActionBar会自动把导航剪头加上，并且清空ActionBar上面的action button(除去overflow按钮)，如下图：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_5B4AFB05-1AFC-4F4F-887F-304187E96E16.png" alt="" /></p>

<p>我们可以在<code>onCreateOptionsMenu</code>中  通过<code>MenuItemCompat.setOnActionExpandListener</code>来监听actionview的扩张事件。</p>

<h2>Action Provider</h2>

<p>上一节提到的actionview，它是直接在ActionBar上面展示出来，ActionProvider是在ActionBar上展示一个下拉的菜单，如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-shareaction@2x.png" alt="" /></p>

<p>创建一个Action provider可以通过指定给<code>android:actionProviderClass</code>属性一个ActionProvider即可。</p>

<h2>添加导航的tab</h2>

<p>这种方式已经不被推荐使用了，所以这里不做详细解释，使用它很简单。</p>

<h2>下拉导航</h2>

<p>下拉导航是在ActionBar的左边提供一个action provider类似的下拉框，可以使用在改变界面内容的频率不频繁的情况下可以使用Drop-down Navigation来进行切换选项的提供，如下图：</p>

<p><img src="http://developer.android.com/images/ui/actionbar-dropdown@2x.png" alt="" /></p>

<p>使用下拉导航有几个步骤：</p>

<ol>
<li>创建一个SpinnerAdapter，提供下拉项的布局</li>
<li>实现一个选择接口 <code>ActionBar.OnNavigationListener</code>，处理事件</li>
<li>在Activity的onCreate里面调用setnavigationMode()</li>
<li>actionbar.setListNavigationCallbacks(spinneradapter,mnavigationcallback),将1和2定义的东西传进去</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android之菜单]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan/"/>
    <updated>2014-12-19T17:19:36+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan</id>
    <content type="html"><![CDATA[<p>本文参考自官方文档：<a href="https://developer.android.com/guide/topics/ui/menus.html">https://developer.android.com/guide/topics/ui/menus.html</a></p>

<p>Android为了维护app之间一个统一的操作习惯，提供了Menus来处理用户和Activity之间的一些交互。但是在不同的系统版本上面推荐的Menu不一样。比如在android 3.0以下，由于Google会要求所有设备生产商提供一个菜单的实体键，所以在3.0一下菜单的主要弹出方式就是点击菜单实体键，弹出6个条目的菜单面板。在3.0以后，引入ActionBar，打开菜单行为转变成点击ActionBar上面的overflow按钮。这两种菜单面板的操作一般都是影响到整个app的操作。</p>

<!--more-->


<p>下图是3.0一下的Option Menu的样子：<br /></p>

<p><img src="https://developer.android.com/images/options_menu.png" alt="" /></p>

<p>这是3.0上的ActionBar的样子：</p>

<p><img src="https://developer.android.com/images/ui/actionbar.png" alt="" /></p>

<p>当然除了上面提到的菜单面板，Android还提供了上下文菜单(Context menu)和弹出菜单(Popup Menu)。尽管存在三种不同的菜单，但是Android提供了一个统一操作的API。</p>

<h2>在XML中定义菜单项</h2>

<p>Menu文件定义的位置在 res/menu目录下，而且顶层元素必须是Menu。在Menu中可以放置item和group，其中group又可以包含多个item。在group中的所有item都会共享某一些熟悉，主要是用来对group进行分类管理,比如设置某一类菜单项的可见。</p>

<p>多级菜单可以通过在item中嵌入Menu来现实。</p>

<h3>选项菜单</h3>

<p>前面已经说到，选项菜单在3.0前后版本存在一些差别。在Fragment和Activity中都可以创建选项菜单,系统会首先显示Activity中创建的item，然后按照fragment加入的顺序添加item。<strong>在3.0一下时，onCreateOptionsMenu是在点击菜单键时触发；在3.0以上，则是在Activity创建时就会调用。</strong></p>

<p>响应点击事件，可以在onOptionsItemSelected中进行。注意这个事件处理函数需要返回一个boolean值。如果已经处理了这次点击需要返回true，否则直接调用super.onOptionsItemSelected()(返回fasle)。这个事件的处理流程是，事件先被送到Activity，然后按照先进先达的顺序，直至莫一个fragement处理了这次点击或者所有的fragment都已经遍历了。</p>

<p>可以在菜单的item中指定<code>android:onClick</code>，这个点击事件的处理函数必须是Activity中签名为public 并且接受一个MenuItem的参数。</p>

<p><strong>更新菜单中的选项</strong>，我们可以通过onCreateOptionsMenu来创建菜单项，但是如果想在运行时改变菜单中的选项，可以重写onPrepareOptionsMenu方法来实现。在3.0以下，这个方法会在菜单键每次按下的时候触发；在3.0以上，由于ActionBar是一直显示的，所以我们如果需要改变菜单，可以主动调用<code>invalidateOptionsMenu()</code>,然后系统会去走onPrepareOptionsMenu。</p>

<h3>上下文菜单</h3>

<p>Contextual Menu主要多用于和界面特别是AdapterView中的某一个item进行交互,通过长按控件来呼出一个Action Menu。如果说Option menu(Actionbar)上面的菜单选项是针对整个app的范围，那么Contextual Menu从名字就可以看出来是针对当前context范围内的操作。存在两种方式：</p>

<ul>
<li>floating context menu，通常在长按ListView中的某一项之后出现。</li>
<li>Contextual action mode，会显示出一个ActionBar，它是一种ActionMode的实现，在3.0系统以上才能使用。</li>
</ul>


<p>下图左边是floating context Menu，右边是Contextual action mode</p>

<p><img src="https://developer.android.com/images/ui/menu-context.png" alt="" /></p>

<h4>floating context menu</h4>

<p>floating context menu是3.0一下版本建议使用的，针对当前Context的一个操作面板，通过长按指定控件呼出。<strong>长按事件如果也被监听，那么会先执行长按事件，再执行onContextItemSelected。如果长按事件处理返回true，那么context Menu不会被呼出</strong>：</p>

<ol>
<li>通过Activity或者Fragment的registerForContextMenu,传入一个View，为它注册一个floating context menu</li>
<li>实现onCreateContextMenu，来创建Menu条目</li>
<li>实现onContextItemSelected处理选择某一个菜单的事件</li>
</ol>


<p>同样需要注意的是在处理事件时，也是由Activity最先接收，然后按照加入顺序分发到每一个Fragment。</p>

<h4>contextual action mode</h4>

<p>从上图可以看到Contextual action和ActionBar颇有几分相似，但是两者直接并无直接关联。在3.0一下版本中，我们需要使用support包中的兼容方案。
单个View使用步骤如下：</p>

<ol>
<li>实现ActionMode.CallBack，这里主要实现action mode的主要逻辑</li>
<li>在合适的时候通过Activity或者fragment的startSupportActionMode来进入一个contextaul action mode。</li>
</ol>


<p>在AdapterView中使用，步骤如下：</p>

<ol>
<li>实现AbsListView.MultiChoiceModeListener，其实这个玩意继承自ActionMode.CallBack，增加了onItemCheckedStateChanged函数，用来处理当AbsListView中某一项的选择状态改变时的操作。</li>
<li>通过设置AbsListView的MultiChoiceModeListener，注意，这里默认进入Action Mode的动作是长按某一个Item。</li>
</ol>


<h3>Popup Menu</h3>

<p>API level 11加入。在android中还提供了一种用来相对于界面上已经存在的一个控件的菜单，比如类似于ActionBar上面的overflow。</p>

<p><img src="https://developer.android.com/images/ui/popupmenu.png" alt="" /></p>

<p>使用Popup Menu的步骤如下：</p>

<ol>
<li>通过context和相对的View创建PopupMenu对象。</li>
<li>通过popupMenu对象来设置Menu的布局和监听事件函数。</li>
</ol>


<p><strong>需要注意的是PopupMenu弹出的位置是自适应的，主要看这个View在那个地方有空间，就会在哪个方向上面弹出来。</strong></p>

<h3>选择菜单项</h3>

<p>选择菜单和前面所提及的菜单类型不同，它仅仅是一种菜单项的表现形式。在本文之前提及的所有菜单中，每一个菜单项的呈现方式都是简单的文字(或者icon),如果我们要加入一种单选框或者复选框的效果，可以使用item的checkable属性。效果如下图：</p>

<p><img src="https://developer.android.com/images/radio_buttons.png" alt="" /></p>

<p>需要注意的是，在option Menu中，如果一个菜单项是以icon的方式显示出来，那么它将不会显示选择框。</p>

<p>我们亦可以通过group来为一组item设置选择条件，这才是它本来的意义。<code>android:checkableBehavior</code>可以设置成radio 或者checkbox或者none，默认应该是checkbox。
<strong>选择菜单项是不能保存状态的，如果app退出，下次再进入状态就不存在了。</strong></p>

<h3>意图菜单项</h3>

<p>如果我们需要在菜单项中通过Intent启动另外一个Activity，Menu提供了专门的类型来处理，这就是Intent Options。而且意图菜单项还可以在系统中解析这个Intent是否能够被Activity了解，如果系统中没有Activity能够接受这个Intent，那么这个意图菜单项将不会展示出来。使用步骤如下：</p>

<ol>
<li>在定义的Intent中增加一个category：<code>CATEGORY_ALTERNATIVE and/or CATEGORY_SELECTED_ALTERNATIVE</code></li>
<li>调用Menu.addIntentOpions()。</li>
</ol>


<p>addIntentOptions方法返回增加的item数目，所以通过Intent解析的item都会被加入菜单中。<strong>这个菜单项的item title就是intent-filter的android:label,icon是application icon</strong></p>

<p>感觉这个东东和settings等系统模块一样，在中国开发者的眼中根本不会去用它，所以老外才会感叹中国做的app怎么这么难用，每个应用的风格都不一样。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpClient]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/16/httpclient/"/>
    <updated>2014-12-16T12:20:26+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/16/httpclient</id>
    <content type="html"><![CDATA[<p>Http协议是在开发中使用最多的网络协议，大部分的网络接口都是通过Http来设计。在Android中提供了两种Http客户端，HttpClient和HttpUrlConnetion。其中后者在低版本存在某些问题，但是HttpClient尽管功能强大，但使用麻烦，接口众多，本文主要是简单介绍HttpClient中使用的一些概念。</p>

<!--more-->


<h2>Request URI</h2>

<p>URI用来表示一个HTTP请求的目标，它由protocol scheme,host名字,port(可选)，resource path,query(可选)和fragment(可选)组成。对应的例子就是：<br />
&ldquo;<a href="http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=">http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=</a>&rdquo;
<br />
apache的HttpClient中(注意，这里将这个apache对于Http的客户端实现的类库统称为HttpClient),提供了URIBuilder来创建一个request URI。</p>

<h2>HttpRequest</h2>

<p>HttpRequest类对应于Http协议中的request line，它主要包括的信息有：Http方法、请求的URI和Http的版本号。</p>

<h2>HttpResponse</h2>

<p>Httpresponse对应于Http协议中的返回中的第一行，包括：协议版本，状态码和状态码的解释。</p>

<h2>HttpMessage</h2>

<p>对应于Http的请求头，所以HttpRequest和HttpResponse都实现了HttpMessage，因为在其中都有Http Head。</p>

<h2>Http entity</h2>

<p>一个Http请求或者响应实际传输的内容，对于请求来说，HTTP规范定义了两种请求方法需要entity：post和put；HTTP期望所有的response都能包含一个entity，当然如果在Head中包含一些出错信息就另当别论。<br />
在HttpClient中依据来源不同，将entity分为三类：</p>

<ul>
<li>streamed：从一个传输流中获得，一般是来自http连接。不可重复。</li>
<li>self-contained：存在内存中，独立于http连接。可以重复。</li>
<li>wrapping：从其他的HttpEntity中获得。依赖于获取的类。</li>
</ul>


<p>注意：以上所说的重复不重复，指的是可不可以多次读取其中的内容，只有self-contained类型的可以重复读取。</p>

<h3>读取entity</h3>

<p>推荐使用流的方式来操作entity中的内容,getContent或者writeTo。HttpClient提供了一个entityUtils类来直接将entity转化成String或者byte数组。不建议使用entityUtils，除非这个响应来自一个可信的server同时可以知道它的长度有限。</p>

<p>如果一个entity需要被多次读取，我们可以使用一个BufferedHttpEntity来将entity缓存至内存中。</p>

<h3>构造entity</h3>

<p>对于post或者put这种可以在请求中附带entity的request(entity enclosing request)，HttpClient提供了多种针对不同数据类型的Entity，比如StringEntity、ByteArrayEntity、InputStreamEntity和FileEntity。</p>

<p>为了模拟HTML表单提交的Post请求，我们可以通过对Post请求设置一个UrlEncodedFormEntity给Post的entity。</p>

<h2>释放资源</h2>

<p>在Http请求得到response之后，我们需要释放资源，可以选择释放content Stream 和 response自身。两者的区别在于：contentStream.close()会保留底层的连接，而response则会关闭整个连接。如果对一个response 返回的内容我们只需要其中一部分的内容，而不需要剩余的部分，可以通过直接关闭response。</p>

<p>注意，我们可以在一个HttpClient执行的request设置一个response handler，然后在handleResponse中处理数据，这样做的好处就是HttpClient会自动去维护资源的释放。</p>

<h2>异常处理</h2>

<p>在HttpClient中，有两类异常：I/O Exception 和 HttpException。前者不是致命的错误，而且也可以恢复，而后者则相反。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[geniousadapter,快速构建Adapter]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter/"/>
    <updated>2014-12-14T20:28:32+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chuyun923/ingenious-adapter"><strong>geniousadapter</strong></a><br/>
前面的话：本项目的原型是<a href="https://github.com/JoanZapata/base-adapter-helper">QuickAdapter</a>，它们的思路基本一致，但本项目的优势在于：</p>

<ul>
<li>支持AdapterView存在多个layout类型</li>
<li>可配置图片加载缓存库</li>
</ul>


<!--more-->


<p>在使用AdapterView时，我们需要使用Adapter来绑定数据源和AdapterView中的每一项数据。通常我们继承自BaseAdapter,然后重写四个方法：</p>

<pre><code>public int getCount()

public Object getItem(int position) 

public long getItemId(int position)

public View getView(int position, View convertView, ViewGroup parent) 
</code></pre>

<p>其中主要的逻辑实现在getView，这个方法主要完成两步操作：1、生成(或者从缓存中取出)当前item对应的ItemView；2、将数据和ItemView绑定。通常，由于AdapterView支持缓存机制(如ListView)，我们通过一个Holder来避免每一次getView重复的findViewById。</p>

<pre><code>private static class Holder {
    TextView tv_name;
    ImageView iv_avatar;
    .....
}

public View getView(int position, View convertView, ViewGroup parent) {
    Holder hodler = null;
    if(converView==null) {
        holder = new Holder();
         convertView = LayoutInflater.from(context)
            .inflate(layoutId, parent, false);
        holder.tv_name = (TextView) findViewById(R.id.tv_name);
        holder.iv_avatar = (ImageView) findViewById(R.id.iv_avatar);
        ...
        //下次就不需要findViewById了
        covertView.setTag(holder);
    }

    holder =(Holder) convertView.getTag();
    holder.tv_name.setText(***);
    holder.iv_avatar.set(***);
} 
</code></pre>

<p>以上就是BaseAdapter的典型用法，那么在项目里面的所有Adapter都存在Holder，并且都存在<code>holder.properties = (ViewType) findViewById(id)</code>的重复代码。可以想象一下，如果Holder中有比较多的属性，特别是如果一个AdapterView具有多个不同类型的layout，那么也需要多个不同Holder，getView将会特别复杂。<br />
<strong>geniousadapter</strong>对getView进行了一层封装，并将getView函数的两部分功能进行拆分，自动完成了生成ItemView和Holder的过程，通过一个抽象方法covert让子类实现数据绑定。子类需要实现两个抽象方法：</p>

<pre><code>  /**
  * 通过AdapterHolder填充view的属性,这个函数主要完成数据绑定的过程，使用方法：
  * holder.setText(R.id.tv_name,"张三").setText(R.id.tv_nickName,
  * "三儿").setImageResource(R.id.iv_avatar,R.drawable.ic_user_avatar);
  * holder 
  * item 当前item需要绑定的数据
  */
  protected abstract void convert(AdapterHolder holder, T item,int viewType);

 /**
  * layoutid至数据类型的映射,插入顺序对应itemviewtype
  * @return
  */
  protected abstract int[] assignLayoutIDs();
</code></pre>

<p><code>holder.setImageUrl(int,imageUrl)</code>可以通过使用者自己定义远程图片加载的方式。用户可以自己实现加载图片或者使用第三方图片加载缓存库，其接口如下：</p>

<pre><code>public interface ImageLoader {

public void load(ImageView imageView,String imageUrl);

//placeResId  默认图resid
public void load(ImageView imageView,String imageUrl,int placeResId);
}
</code></pre>

<p>比如我们可以使用picasso来完成加载图片的功能，在合适的位置来指定：</p>

<pre><code>DefaultAdapterConfig.setImageLoader(new ImageLoader() {
    @Override
    public void load(ImageView imageView, String imageUrl) {
        picasso.load(imageUrl).into(imageView);
    }

    @Override
    public void load(ImageView imageView, String imageUrl, int placeResId) {
        picasso.load(imageUrl).placeholder(placeResId).into(imageView);
    }
});
</code></pre>

<p>总结：genious Adapter可以使用户在getView方法中无需关注每一项ItemView生成的细节，而只需要处理数据绑定的逻辑即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的泛型方法]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa/"/>
    <updated>2014-12-04T16:36:56+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>在通过反射获取类的私有域时希望写一个方法，可以指定一个域的名字和域的类型，可以返回指定类型的对象。</p>

<!--more-->


<p>方法实现如下：</p>

<pre><code>/**
 * 获取一个类的私有域
 * @param fromClass 私有域所在的类
 * @param fieldName 域的名字
 * @param &lt;T&gt;
 * @return
 */
private &lt;T&gt; T getPrivateFiled(Class&lt;T&gt; fromClass, String fieldName) {
    T result = null;
    try {
        Field field = fromClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        result = (T) field.get(this);
    } catch (NoSuchFieldException e) {
    } catch (IllegalAccessException e) {
    }
    return result;
}
</code></pre>

<p>泛型方法的结构如下：<br />
<img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_java%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95.png" alt="image" />
<br />
值得说明的是，声明泛型方法首先需要在返回值前面用<code>&lt;T&gt;</code>表明这是一个泛型方法，持有一个泛型。当然，一般来说我们需要在参数中传入一个class对象，不然函数的泛型没有任何意义了。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress写博客的个性配置]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/22/first/"/>
    <updated>2014-11-22T14:09:59+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/22/first</id>
    <content type="html"><![CDATA[<!--more-->


<h2>配置_config.yml</h2>

<ul>
<li>在首页只显示部分文章，而不是全文，可以通过<code>_config.yml</code>来设置，该文件中使用键值对来存储，<strong>键名: value</strong>中间的空格不能少。<code>excerpt_separator</code>，摘要标志，如果一篇文章中出现了这个标志，表明此文章在首页现实时需要采用摘要的模式，默认为<code>&lt;!--more--&gt;</code>。<code>excerpt_link</code>为读更多的link显示的文字，我们可以设置为&#8221;阅读全文&#8221;。</li>
</ul>


<h2>新建博客</h2>

<ul>
<li><p>设置使用指定的编辑器自动打开新建的blog。现在每次新建一篇blog，都要跑到<code>/source_posts</code>里面去打开，先到Rakefile文件里面的<code>## -- Misc Configs -- ##</code>注释下，在<code>server_port</code>下面新增一个键值对<code>editor = "open -a Mou"</code>。<br />
然后在文件中找到<code>new_post</code>任务，在最后一个<code>end</code>之前添加如下代码：</p>

<pre><code>  if #{editor}
      system "#{editor} #{filename}"
  end
</code></pre>

<p>如此一来，每次<code>rake new_post</code>都会自动打开Mou编辑器。</p></li>
<li><p>preview的时候自动打开浏览器预览。还是在<code>Rakefile</code>中，找到preview任务，加入代码</p>

<pre><code>  system "sleep 2; open http://localhost:#{server_port}/"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
