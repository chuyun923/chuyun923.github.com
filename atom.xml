<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[楚云之南]]></title>
  <link href="http://chuyun923.github.io/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2015-07-31T15:52:12+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[View事件传递之父View和子View之间的那点事]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/28/viewshi-jian-zhi-fu-viewhe-zi-viewzhi-jian-de-na-dian-shi/"/>
    <updated>2015-07-28T09:29:14+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/28/viewshi-jian-zhi-fu-viewhe-zi-viewzhi-jian-de-na-dian-shi</id>
    <content type="html"><![CDATA[<h1>View事件传递之父View和子View之间的那点事</h1>

<p><code>Android</code>事件传递流程在网上可以找到很多资料，<code>FrameWork</code>层输入事件和消费事件，可以参考：</p>

<ol>
<li><a href="http://blog.csdn.net/stonecao/article/details/6759189">Touch事件派发过程详解</a></li>
</ol>


<p>这篇blog阐述了底层是如何处理屏幕输，并往上传递的。Touch事件传递到Activity的<code>DecorView</code>时，往下走就是<code>ViewGroup</code>和子<code>View</code>之间的事件传递，可以参考郭神的这两篇博客</p>

<ol>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9097463">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/9153747">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></li>
</ol>


<p>郭神的两篇博客清楚明白地说明了View之间事件传递的大方向，但是具体的一些晦暗的细节阐述较少，本文主要是总结这两篇博客的同时，侧重于两点：</p>

<ol>
<li>事件分发过程中一些细节到底如何实现的？</li>
<li>子view到底如何和父View抢事件，父View又是如何拦截事件不发送给子View，以及如果我们需要处理这种混乱的关系才能让两者和谐相处？。</li>
</ol>


<h2>MotionEvent抽象</h2>

<p>要明白View的事件传递，很有必要先说一下Touch事件是如何在Android系统中抽象的，这主要使用的就是MotionEvent。这个类经历了几次重大的修改，一次是在2.x版本支持多点触摸，一次是4.x将大部分代码甩给native层处理。</p>

<h3>一次简单的事件</h3>

<p>我们先举个栗子来说明一次完整的事件，用户触屏 滑动 到手机离开屏幕，这认为是一次完整动作序列(<code>movement traces</code>)。一个动作序列中包含很多动作<code>Action</code>，比如在用户按下时，会封装一个MotionEvent，分发给视图树，我们可以通过<code>motionevent.getAction</code>拿到这个动作是<code>ACTION_DOWN</code>。同样，在手指抬起时，我们可以接收到Action类型是<code>Action_UP</code>的MotionEvent。对于滑动(MOVE)这个操作，Android为了从效率出发，会将多个MOVE动作打包到一个MotionEvent中。通过getX getY可以获取当前的坐标，如果要访问打包的缓存数据，可以通过getHistorical**()函数来获取。</p>

<h3>加入多点触摸</h3>

<p>对于单点的操作来看，MotionEvent显得比较简单，但是考虑引入多点触摸呢？我们定义一个接触点为(Pointer)。我们从onTouch接受到一个MotionEvent，怎么拿到多个触碰点的信息？为了解开笔者刚开始学习这部分知识时的困惑，我们首先树立起一种概念：一个MotionEvent只允许有一个Action(动作)，而且这个Action会包含触发这次Action的触碰点信息，对于MOVE操作来说，一定是当前所有触碰点都在动。只有<code>ACTION_POINTER_DOWN</code>这类事件事件会在Action里面指定是哪一个POINTER按下。</p>

<p>在MotionEvent的底层实现中，是通过一个16位来存储Action和Pointer信息【PointerIndex】。低8位表示Action，理论上可以表示255种动作类型;高8位表示触发这个Action的PointerIndex，理论上Android最多可以支持255点同时触摸，但是在上层代码使用的时候，默认多点最多存在32个，不然事件在分发的时候会有问题。</p>

<p>MotionEvent中多个手指的操作API大部分都是通过pointerindex来进行的，如：获取不同Pointer的触碰位置,getX(int pointerIndex);获取PointerId等等。大部分情况下，pointerid == pointeridex。</p>

<p><code>ACTION_DOWN</code> OR <code>ACTION_POINTER_DOWN</code>:</p>

<p>这两个按下操作的区别是<code>ACTION_DOWN</code>是一个系列动作的开始，而<code>ACTION_POINTER_DOWN</code>是在一个系列动作中间有另外一个触碰点触碰到屏幕。</p>

<p>这部分详细的描述，请参考：
<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent</a></p>

<p>到这里，铺垫终于结束了，我们开始直奔主题。</p>

<h2>View的事件传递</h2>

<p>Android的Touch事件传递到Activity顶层的DecorView(一个FrameLayout)之后，会通过ViewGroup一层层往视图树的上面传递，最终将事件传递给实际接收的View。下面给出一些重要的方法。如果你对这个流程比较熟悉的话，可以跳过这里，直接进入第二部分。</p>

<h3>dispatchTouchEvent</h3>

<p>事件传递到一个ViewGroup上面时，会调用dispatchTouchEvent。代码有删减</p>

<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {

    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

        // Attention 1 ：在按下时候清除一些状态
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            //注意这个方法
            resetTouchState();
        }

        // Attention 2：检查是否需要拦截
        final boolean intercepted;
        //如果刚刚按下 或者 已经有子View来处理
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            //  不是一个动作序列的开始 同时也没有子View来处理，直接拦截
            intercepted = true;
        }

          //事件没有取消 同时没有被当前ViewGroup拦截，去找是否有子View接盘
        if (!canceled &amp;&amp; !intercepted) {
                //如果这是一系列动作的开始  或者有一个新的Pointer按下 我们需要去找能够处理这个Pointer的子View
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                final int actionIndex = ev.getActionIndex(); // always 0 for down

                //上面说的触碰点32的限制就是这里导致
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);

                    //对当前ViewGroup的所有子View进行排序，在上层的放在开始
                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null
                            &amp;&amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = customOrder
                                ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null)
                                ? children[childIndex] : preorderedList.get(childIndex);

                              // canViewReceivePointerEvents visible的View都可以接受事件
                              // isTransformedTouchPointInView 计算是否落在点击区域上
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                              //能够处理这个Pointer的View是否已经处理之前的Pointer，那么把
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }                           }
                        //Attention 3 : 直接发给子View
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                    }
                }

            }
        }

        // 前面已经找到了接收事件的子View，如果为NULL，表示没有子View来接手，当前ViewGroup需要来处理
        if (mFirstTouchTarget == null) {
            // ViewGroup处理
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {

            if(alreadyDispatchedToNewTouchTarget) {
                                //ignore some code
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                }
            }

        }
    return handled;
}
</code></pre>

<p>上面代码中的Attention在后面部分将会涉及，重点注意。</p>

<p>这里需要指出一点的是，一系列动作中的不同Pointer可以分配给不同的View去响应。ViewGroup会维护一个PointerId和处理View的列表TouchTarget，一个TouchTarget代表一个可以处理Touch中Pointer的子View，当然一个View可以处理多个Pointer，比如两根手指都在某一个子View区域。TouchTarget内部使用一个int来存储它能处理的PointerId，一个int 32位，这也就是上层为啥最多只能允许同时最多32点触碰。</p>

<p>这里可以看到，ViewGroup真正处理事件是在dispatchTransformedTouchEvent里面，跟进去看看：</p>

<h3>dispatchTransformedTouchEvent</h3>

<pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {

      //没有子类处理，那么交给viewgroup处理
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }
    return handled;
}
</code></pre>

<p>可以看到这里不管怎么样，都会调用View的dispatchTouchEvent,这是真正处理这一次点击事件的地方。</p>

<h3>dispatchTouchEvent</h3>

<pre><code>    public boolean dispatchTouchEvent(MotionEvent event) {
        if (onFilterTouchEventForSecurity(event)) {
        //先走View的onTouch事件，如果onTouch返回True
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }
      return result;
    }
</code></pre>

<p>我们给View设置的onTouch事件处在一个较高的优先级，如果onTouch执行返回true，那么就不会去走view的onTouchEvent，而我们一些点击事件都是在onTouchEvent中处理的，这也是为什么onTouch中返回true，view的点击相关事件不会被处理。</p>

<h3>小小总结一下这个流程</h3>

<p>ViewGroup在接受到上级传下来的事件时，如果是一系列Touch事件的开始(ACTION_DOWN)，ViewGroup会先看看自己需不需要拦截这个事件(onInterceptTouchEvent，ViewGroup的默认实现直接返回false表示不拦截)，接着ViewGroup遍历自己所有的View。找到当前点击的那个View，马上调用目标View的dispatchTouchEvent。如果目标View的dispatchTouchEvent返回false，那么认为目标View只是在那个位置而已，它并不想接受这个事件，只想安安静静的做一个View(我静静地看着你们装*)。此时，ViewGroup还会去走一下自己dispatchTouchEvent，Done！</p>

<h2>子View和父View的撕*大战</h2>

<p>终于来到本文的重要环节，子View和父布局(ViewGroup)是如何撕逼的。我们经常遇到这样的问题：在ListView中放一个ViewPager不能滑动的问题，其实这里就会涉及到子View和布局之间的协商，到底你上还是我上。</p>

<p>首先需要明确一点的是，一个事件肯定是由ViewGroup传递给自己的子View的，所以ViewGroup具有绝对的权威来禁止事件往下传，这就是onInterceptTouchEvent方法。可以看上面ViewGroup中的dispatchTouchEvent的Attention 1 和 Attention 2。</p>

<p>先看Attetion2：
进行判断有有两个条件：1，如果是一次新的事件 or  在一次事件中但是已经有子View来处理这个事件，那么父类需要去看看是否拦截这次事件。否则，直接拦截(此时处于一系列动作的中间，而且没有子view来接盘，那么ViewGroup就直接拦下来)。</p>

<p>决定是否拦截有两个步骤，</p>

<ol>
<li>disallowIntercept 是否驳回拦截，默认false。注意这个值是子View和撕*的关键，因为ViewGroup开放了给这个标记赋值的接口requestDisallowInterceptTouchEvent()，而且这个方法直接往上递归，这个ViewGroup的各级父容器都会设置驳回拦截。</li>
<li>onInterceptTouchEvent 虽然ViewGroup中默认返回false，但是在很多有滑动功能的ViewGroup里面(如scrollview ListView等)会处理各种情况，决定是否拦截这个事件，所以就会出现之前说的ListView中的Viewpager不能滑动的问题，原因是事件被父View拦截了。</li>
</ol>


<p>在Attetion1的位置如果是一次新的ACTION_DOWN，那么会把之前事件传递设置的各种状态清除。</p>

<h3>对ViewGroup来说需要做什么</h3>

<p>对于一个需要拦截事件的ViewGroup，它通常都有一些特殊的操作，比如ScrollView，比如ViewPager，它重写onInterceptTouchEvent是非常关键的，这也是能和子View和谐相处的关键。举个例子，我自己定义了一个ViewGroup：</p>

<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if(ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
        return true;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre>

<p>这样会发生什么？</p>

<p>所有位于MyViewGroup中的子View收不到任何的事件，原因可以看一下Attention2的代码，判断是否拦截是在系列动作按下时会进行判断，如果此时拦截，那么直接不会去查找相应处理的子View，所以touchtarget为空，那么接下来的动作都直接被ViewGroup笑纳。</p>

<p>所以哪怕再强势的ViewGroup，一般都是在Down的时候给子类机会去掉用<code>requestDisallowInterceptTouchEvent</code>，如设置驳回拦截，那么在ViewGroup分发事件的时候，会跳过onInterceptTouchEvent的执行。</p>

<h3>子View需要做什么</h3>

<p>对于子View来说，在合适的时机调用requestDisallowInterceptTouchEvent即可。当然啥时候合适？对于一个View来说，那就是在dispatchTouchEvent或者onTouchEvent来调用。</p>

<p>对于ViewGroup来说，通常我们会在onInterceptTouchEvent进行判断。比如我们经常会遇到在ListView里面套了ViewPager导致ViewPager不能滑动的问题，通常的处理方式：</p>

<pre><code> @Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    if (absListView != null) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDownX = event.getX();
                mDownY = event.getY();
                    //ACTION_DOWN的时候，赶紧把事件hold住
                getParent().requestDisallowInterceptTouchEvent(true);
                break;
            case MotionEvent.ACTION_MOVE:

                if(Math.abs(event.getX() - mDownX)&gt;Math.abs(event.getY()-mDownY)) {
                    getParent().requestDisallowInterceptTouchEvent(true);
                }else {
                    //发现不是自己处理，还给父类
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                    //其实这里是多余的
                getParent().requestDisallowInterceptTouchEvent(false);
        }

    }
    return super.onInterceptTouchEvent(event);
}
</code></pre>

<h2>总结</h2>

<p>本来打算写一个短篇的，结果一个不小心，弄成了长篇大论。</p>

<p>最后需要注意一点的是，所有我们上述讨论的内容都是在一层层递归中进行,而且requestDisallowInterceptTouchEvent这个函数也是递归调用的。</p>

<p>我们可以认为ViewGroup是一个具有绝对话语权但是从不专政的霸道总裁，它自己可以拦截处理某些事件，比如Viewpager的横滑，但是它也可以给子View足够的空间去要求这个事件给自己处理。作为一名开发者，一方面在自己定义ViewGroup时需要考虑能够给子View足够空间中断自己的拦截；一方面自己定义View时，我们需要在合适的时候跟父View索要事件。ViewPager作为容器来说，它需要拦截横滑事件，同时，自己具备了和父View争抢事件的能力，所以不管把ViewPager放到什么布局中，它都能正确处理。看看它的onInterceptTouchEvent怎么写的吧，完美的体现了这一思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recyclerviewde Keng]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/15/recyclerviewde-keng/"/>
    <updated>2015-07-15T00:00:00+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/15/recyclerviewde-keng</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>使用<code>RecyclerView</code>版本时，报如下异常：</p>

<pre><code>java.lang.NullPointerException: Attempt to invoke virtual method 'void android.support.v7.widget.RecyclerView$LayoutManager.stopSmoothScroller()' on a null object reference
</code></pre>

<p>查看堆栈，是在Activity的Destory方法一路调用到<code>RecyclerView</code>的<code>onDetachedFromWindow</code>里面报的NPE。</p>

<!-- more-->


<h2>原因</h2>

<p>Activity在销毁时，回去调用View中的<code>onDetachedFromWindow</code>,搂一眼代码：</p>

<pre><code> @Override
protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (mItemAnimator != null) {
        mItemAnimator.endAnimations();
    }
    mFirstLayoutComplete = false;

    stopScroll();
    mIsAttached = false;
    if (mLayout != null) {
        mLayout.onDetachedFromWindow(this, mRecycler);
    }
    removeCallbacks(mItemAnimatorRunner);
}

 public void stopScroll() {
    setScrollState(SCROLL_STATE_IDLE);
    stopScrollersInternal();
}

/**
 * Similar to {@link #stopScroll()} but does not set the state.
 */
private void stopScrollersInternal() {
    mViewFlinger.stop();
    //什么！！！！
    mLayout.stopSmoothScroller();
}
</code></pre>

<p><code>stopScrollersInternal</code>中没有判空。</p>

<h2>其他问题</h2>

<p>其实这个问题还有另外一个版本，如果在XML中定义了一个<code>RecyclerView</code>,而不调用<code>setLayoutManager</code>,会直接crash，NPE报得飞起。大概是在<code>OnMeasure</code>里面直接调用了<code>LayoutManager</code> 的方法导致的，问题也是同一个，木有判空。
人与人之间基本的信任呢？我在xml里面定义一个view，不在代码里面执行指定操作就crash，略屌。。。</p>

<h2>解决方案</h2>

<p><a href="http://stackoverflow.com/questions/26702633/why-am-i-getting-a-null-reference-on-my-recyclerview/26908738#26908738">stackoverflow</a>
让我们继承RecyclerView，然后重写方法。</p>

<p>不过我发现在最新的support包里面，也就是RecyclerView的5.1.0_r1版本已经修复了这个问题,google大法好！</p>

<p>对于上面提到第二个问题，如果在<code>onMeasure</code>的时候<code>LayoutManager</code>为空，那么<code>RecyclerView</code>会给一个默认值。</p>

<p>所以你需要做的仅仅是升级到最新版本即可。</p>

<p><code>compile 'com.android.support:recyclerview-v7:22.2.0'</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 视图树状态保存]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun/"/>
    <updated>2015-07-13T18:13:40+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun</id>
    <content type="html"><![CDATA[<h1>Android 视图树状态保存</h1>

<h2>FragmentTabHost引起的思考</h2>

<p>公司的项目是一个标准的<code>FragmentTabHost</code>与<code>Fragment</code>构成的四TAB布局。其中三个TAB中都包含有<code>ListView</code>来展现一个列表。用户在切换TAB时，<code>ListView</code>的当前位置会自动被保存，切换回来之后会自动滚动到上次的位置。</p>

<p>我们知道<code>FragmentTabHost</code>内部对于<code>Fragment</code>的切换使用的是<code>attach</code>和dettach，此时必然会走Fragment的视图树的重建，也就是在切换tab的时候，fragment的UI元素会进行重建，当然也包括重建其中的ListView。那为什么在重建之后Listview能找到正确位置？为了找到解释，我开始查阅代码。</p>

<!--more-->


<p>第一个想法是否是我们通过<code>Fragment</code>的<code>onSaveInstanceState</code>和<code>Bundle</code>来保存的呢？但是看<code>Fragment</code>中的方法并没有任何代码进行保存，也没有进行恢复。</p>

<p>有人告诉我是通过<code>Adapter</code>来进行保存的，因为我们的<code>Fragment</code>会持有<code>listview</code>使用的<code>ListAdapter</code>，所以在重建的时候<code>listadapter</code>实际上复用之前的<code>adapter</code>，但是，通查adapter的代码，发现并没有任何保存当前位置的代码。</p>

<p>这样不科学的事情怎么会发生？一个新创建出来的ListView居然会保存之前一个ListView的状态？</p>

<h2>Android View状态保存</h2>

<p>我们经常有这样的经验，在一个<code>EditText</code>中我们输入一些文字，在屏幕翻转时，<code>EditText</code>进行重建，其中的文字还会保留(前提是你为这个<code>EditText</code>指定了ID)。
解释这个问题，我们需要从<code>Android</code>的<code>View</code>状态保存机制说起。</p>

<p>在<code>View</code>中<code>Android</code>定义了<code>saveHierarchyState</code>，它用来保存这个<code>View</code>所在的视图树的状态，传进来的参数是父<code>view</code>保存的状态，看到这里，你应该已经意识到了这又是<code>android View</code>中常用的递归伎俩。</p>

<pre><code>    public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) {
        dispatchSaveInstanceState(container);
     }

    protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
      //这里可以看到如果你不指定view的ID，系统是不会给你保存view的状态的
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        //获取当前View需要保存的Parcelable
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    "Derived class did not call super.onSaveInstanceState()");
        }
        if (state != null) {
            // Log.i("View", "Freezing #" + Integer.toHexString(mID)
            // + ": " + state);

            //妈蛋，直接是简单粗暴的 viewId ----&gt; Parcelable的映射
            container.put(mID, state);
        }
    }
}
</code></pre>

<p>从上面的代码，我们可以大致想象一下<code>saveHierarchySate</code>的过程，顶层的<code>view</code>调用<code>saveHierarchyState</code>,然后<code>dispatchSaveInstanceState</code>保存自己，为了让递归走下去，我们都能想象到在<code>ViewGroup</code>中的<code>dispatchSaveInstanceState</code>会调用子<code>View</code>的<code>saveHierachySate</code>，是不是这样呢，搂一眼<code>ViewGroup</code>中的代码：</p>

<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    //先把自己放到SparseArray中
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    //保存孩儿们的状态
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre>

<p>看到这里，相信你已经迫不及待想要看顶层<code>View</code>是在什么时机保存视图树信息的，Activity中的<code>onSaveInstanceState</code>有如下语句：</p>

<pre><code>outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
</code></pre>

<p>这里调用了跟到<code>PhoneWindow.saveHierarchyState()</code>,</p>

<pre><code>SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
mContentParent.saveHierarchyState(states);
</code></pre>

<p>这里交代地很清楚明白。ok，总结一下这个流程</p>

<p><code>Acitvity</code>在状态需要保存时，直接new了一个<code>SparseArray</code>，建立m<code>ovieId</code>和<code>Parcelable</code>的映射，其中每一个<code>View</code>都会使用一个<code>Parcelable</code>来序列化需要保存的内容，<code>ViewGroup</code>在保存了自己的同时，也会去调用子类的保存状态的方法，并把上面传下来的<code>SparseArray</code>一直往下传。</p>

<h2>视图树状态恢复</h2>

<p><strong>视图树保存下来的SparsesArray不是被ViewGroup自己持有(避免View被重新new出来，这些信息丢失，这也是前面疑惑的根源)。</strong>以<code>Activity</code>为例，我们可以看到整个视图树状态保存之后会放到一个<code>Bundle</code>中，那我们来看看视图树是如何恢复的。</p>

<p>在<code>Activity</code>的<code>onRestoreInstanceState</code>中</p>

<pre><code>    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
        }
    }
</code></pre>

<p>跟到<code>PhoneWindow</code>中的<code>restoreHierarchyState</code></p>

<pre><code>    SparseArray&lt;Parcelable&gt; savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
</code></pre>

<p>从Bundle中拿出之前保存的SparseArray，丢给顶层View的<code>restoreHierarchyState</code></p>

<pre><code>    public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) {
    dispatchRestoreInstanceState(container);
    }

    protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID) {
          //拿到当前View的id对应的Parcelable，注意，这个Parcelable很有可能是之前id相同的View保存的
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i("View", "Restoreing #" + Integer.toHexString(mID)
            // + ": " + state);
            mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(
                        "Derived class did not call super.onRestoreInstanceState()");
            }
        }
    }
    }
</code></pre>

<p>调用到View的<code>onRestoreInstanceState</code>，这里让子类去处理拿出的信息。</p>

<p>到这里，可以猜到在ViewGroup的<code>dispatchRestoreInstanceState</code>调用super方法(恢复自己)，同时应该会去恢复所有子View，这里不上代码了。</p>

<h2>回到Fragment状态保存的问题</h2>

<p>虽然<code>attach</code>和<code>dettach</code>并不会引起Activity的状态保存，但是由于视图树保存状态的机制可以知道，Fragment也可以只保留自己所持有的View，然后恢复Fragment的视图树。</p>

<p>在<code>FragmentManager</code>的<code>moveToState</code>方法中，调用了<code>saveFragmentViewState</code></p>

<pre><code>void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    //f.mView是Fragment的顶层View
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre>

<p> 往下走和Activity恢复视图树的过程一样鸟！</p>

<p> 这样看起来，ListView能够恢复到上次保存的位置，可以看到AbsListView中的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>进行了保存和恢复，其中保存一个变量 <code>mSyncPosition = ss.position;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Content Provider]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/16/android-provider/"/>
    <updated>2015-04-16T10:58:35+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/16/android-provider</id>
    <content type="html"><![CDATA[<p><code>ContentProvider</code>作为Android应用之间共享数据的桥梁，为共享数据提供了一个统一的访问方式(一套统一的接口)。</p>

<!--more-->


<h2>URI</h2>

<p>在Android中大量使用URI作为资源定位标识，它主要由 <code>scheme host(authority) path params组成</code>。例如我们有如下的一个<code>Content Provider</code>的URI如下：</p>

<pre><code>content://www.chuyun923.com/books/10086/title/firstWord
</code></pre>

<p>其中<code>content</code>，是Android为Content Provider规定的scheme；
PATH(<code>books/10086/title/firstWord</code>)可以直接表示用来操作的业务，表示书籍<code>_ID=10086</code>的书名的第一个单词。<strong>注意，我们可以在URI中定义各种奇葩的PATH来描述业务，但是的最终解释权归Content Provider的定义</strong></p>

<p>既然我们可以指定一些PATH表示业务，那么<code>Content Provider</code>必然需要去解析各种PATH，然后提供各种匹配的处理逻辑，此时，UriMatcher应运而生。</p>

<h3>UriMatcher</h3>

<p>对一个给定的Uri进行HOST和PATH的匹配，而Scheme不在考虑范围。对于PATH的匹配主要是挨个去比较各个PATH参数是否相等。</p>

<p>使用UriMatcher，首先需要给它配置一些配置URI，以及映射的<code>int</code>。</p>

<pre><code>    private static final UriMatcher uriMatcher;
    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("net.manoel.provider.Books", "books", 1);
        uriMatcher.addURI("net.manoel.provider.Books", "books/#/title", 2);
        uriMatcher.addURI("net.manoel.provider.Books","books/#/title/firstword",3);
    }
</code></pre>

<p>这里配置了三个业务PATH，第一个表示整个<code>books</code>整个表。第二URI表示指定Id的书名，第三个表示指定id的书名的首单词。</p>

<p>那么，
<code>books/12/title</code>将匹配第二个，在<code>Content Provider</code>收到这个<code>URI</code>时，可以使用<code>UriMatcher</code>得到2。
UriMatcher为URI提供了两种通配符 <code>#</code>代表数字；<code>*</code>代表任意字符。</p>

<p><strong>需要注意一点的是</strong>，<code>UriMatcher</code>进行匹配，会受到<code>addURI</code>的先后顺序影响。</p>

<p>如：<code>uriMatcher</code>按以下顺序添加：</p>

<pre><code>*/#
#/*
</code></pre>

<p>那么 <code>9/title</code>将不能获得匹配，是不是很奇怪？</p>

<pre><code>*/#/#
*/*/*
</code></pre>

<p> <code>books/10/title</code>也不能被匹配。</p>

<p>在匹配PATH是挨个参数进行，一旦一个路径参数被匹配，那么它就不会更换。
以<code>books/10/title</code>来说，匹配第一个patten的第一个参数 * 通过，10 匹配 <code>#</code>也通过，title不能匹配#，那么此时进行第二个patten的匹配。那么第二个patten必须满足<code>*/#</code>开头，否则就算是 <code>*/*</code>也不能通过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中日期时间API小结]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/15/"/>
    <updated>2015-04-15T17:47:06+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/</id>
    <content type="html"><![CDATA[<p>Java中为处理日期和时间提供了大量的API，确实有把一件简单的事情搞复杂的嫌疑，各种类：<code>Date Time Timestamp Calendar...</code>，但是如果能够看到时间处理的本质就可以轻松hold住这堆东西了。</p>

<!--more-->


<h2>常用的类</h2>

<h3>表示类</h3>

<ul>
<li><code>java.util.Date</code> :能够准确记录到毫秒级别的时间表示类，但是其中的各种get set(修改时间或者获取时间中某一个特殊参数)都已经被废弃。</li>
<li><code>java.sql.Date</code> :为数据库提供的日期类，继承自<code>util</code>包中的<code>Date</code>，但是这个类只能够操作日期，不能读取或者修改时间。<strong>sql和util中Date内部进行存储的long，都可以保存到毫秒级别</strong></li>
<li><code>java.sql.Time</code> :为数据库提供的时间类，和<code>Date</code>相反，它只能获取和操作时间相关的信息。</li>
<li><code>java.sql.Timestamp</code>:时间戳，继承<code>util.Date</code>，它不仅能够完美支持<code>util.Date</code>的功能，而且可以支持到纳秒级别(10^-9 s)。</li>
</ul>


<h3>工具类</h3>

<ul>
<li><code>Calendar</code>:主要用来操作一个<code>Date</code>类型，提供了一系列接口来获取或修改其中的信息。</li>
<li><code>TimeZone</code>:用来配合<code>Calendar</code> 操作<code>Date</code>，主要是考虑时区的问题，值得注意的是，在<code>Date</code>中存储的信息是一个<strong>绝对标准时间(稍后说明)</strong>，而如果需要进行时区的转化，那么只需要配合此类即可。</li>
<li><code>SimpleDateFormat</code>:常用的格式化<code>Date</code>的工具，主要是进行<code>String</code>和日期之间的互换。</li>
</ul>


<h2>基本概念</h2>

<h3>时间的来源</h3>

<p>注意，这里并不是讨论一个哲学的问题，在大部分的编程语言中，我们都是采用从1970-01-01 00:00:00.000 开始至今的毫秒差作为表示时间的数值，<strong>这个时间是绝对公立的，它和时区没有任何关系</strong>。在Java中任何时间的表示类的底层存储的毫秒数都是一个这样的标准时间。</p>

<p>在java中获取当前时间接口是<code>System.currentTimeMillis()</code>。</p>

<p>值得一提的是Java还提供了一个更加精确的时间：<code>System.nanoTime()</code>，获取一个时间精确到纳秒，但是它并不是一个当前的精确时间，而是JVM提供的一个时间，它的主要用途是来精确衡量两个时间段之间的时间，如计算一段代码的执行时间：</p>

<pre><code>    long startTime = System.nanoTime();
   // ... the code being measured ...
   long estimatedTime = System.nanoTime() - startTime;
</code></pre>

<p>可以比较两个接口返回的内容：
    <code>System.currentTimeMillis()</code>:1429108246639
    <code>System.nanoTime()</code>:1429108246640(ms)089000&mdash;&mdash;->多了6位</p>

<h3>UTC和GMT</h3>

<p>这两个标准唯一不同之处在于UTC是基于GMT进行微调之后的一个时间，本文不去深究这两者的差别，在此认为这两者是一个东西。</p>

<p>初中地理教过我们，地球是24个时区，东部和西部各12个，时区的基准点是伦敦(基准UTC)，往东，会领先UTC，往西，会落后UTC。</p>

<p>如北京属于东八区，那么我们的时间会领先基准，也就是我们在早上9点时，伦敦是早上1点。如果我们在不同时区接发邮件的时候，可以发现这个问题。</p>

<p>这个时间是我收到一份来自华盛顿的邮件的时间：</p>

<p>2014年1月23日(星期四) 晚上7:29 (UTC-05:00 华盛顿、多伦多、古巴、智利时间)</p>

<p>这里我们可以在邮件时间后面发现<code>UTC-05:00</code>，说明这里是落后UTC基准5个小时。注意，前面的时间是发件人的本地时间，如果转化成北京所在时区的时间应该是加上13h，那我收到这封邮件的本地时间是：2014-01-24 星期五早上8:29。</p>

<h3>再谈TimeStamp</h3>

<p>前面说了，TimeStamp能够精确到纳秒，那它是怎么做到的呢？由于TimeStamp继承自<code>Date</code>，它把整数秒存储在超类中，而在子类中专门用一个long类型存储零的秒数:<code>nanos</code></p>

<p>需要注意，除非你显示去调用TimeStamp的这个构造器:
<code>public Timestamp(int year, int month, int date,
                     int hour, int minute, int second, int nano)</code></p>

<p>显示去指定nano的值，否则这个构造器的参数
<code>public Timestamp(long time)</code></p>

<p>的单位实际上是毫秒。</p>

<h2>API的使用</h2>

<p>最后再来说说日期时间的操作接口，过程基本如下图：</p>

<pre><code>           SimpleDateFormat &lt;------&gt;  Date   &lt;---------&gt; Calendar
</code></pre>

<p>Date负责存储一个绝对时间，并对两边提供操作接口。Calendar负责对Date中特定信息，比如这个时间是改年的第几个星期，此外，还可以通过set,add,roll接口来进行日期时间的增减。SimpleDateFormat主要作为一些格式化的输入输出。</p>

<h3>SimpleDateFormat</h3>

<p><code>SimpleDateFormat</code>的构造器接受一个String pattern，其中的pattern是预定义的：</p>

<pre><code>G 年代标志符
y 年
M 月
d 日
h 时 在上午或下午 (1~12)
H 时 在一天中 (0~23)
m 分
s 秒
S 毫秒
E 星期
D 一年中的第几天
F 一月中第几个星期几
w 一年中第几个星期
W 一月中第几个星期
a 上午 / 下午 标记符 
k 时 在一天中 (1~24)
K 时 在上午或下午 (0~11)
z 时区
</code></pre>

<p>例子1：</p>

<pre><code> SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
            "yyyy-MM-dd E HH:mm");

    java.util.Date date = new java.util.Date();
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(date));

    //output: 2015-04-15 星期三 23:59 
    //当然，反过来，我也可以使用这个format将output的字符串转化成Date
</code></pre>

<h3>Calendar</h3>

<p>Calendar中主要需要了解的各种操作域，感觉这也是Java在做这个API时的一个败笔，灵活有余，可控性不足，初学者如果乱用域，将会产生各种bug。至于每一个域对应的时间分量，请自行google。</p>

<p>一些常用的filed：</p>

<ul>
<li>YEAR:年</li>
<li>MONTH：月（从0 开始，0 表示1月&hellip;.11表示12月）</li>
<li>DAY_OF_MONTH :几号（等同DATE）</li>
<li>DAY_OF_WEEK：星期几</li>
<li>DAY_OF_YEAR：年里面的天</li>
<li>DATE:几号（等同DAY_OF_MONTH）</li>
</ul>


<p>一个filed通常来说对应了日期时间中的某一个分量，在操作这个分类有些操作会向高位进位，而有的操作则不会【<strong>bug高发区域</strong>】。</p>

<p>例子2：</p>

<pre><code>SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
     "yyyy-MM-dd E");
    Calendar calendarT = Calendar.getInstance(Locale.CHINA);
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.MONTH,12);// 月份进位
    System.out.println(DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    //output:   2015-04-16 星期四
                    2016-01-16 星期六
</code></pre>

<p>例子3：</p>

<pre><code>        SimpleDateFormat DATETIME_FORMATER_WITHWEEK = new SimpleDateFormat(
     "yyyy-MM-dd E");
    Calendar calendarT = Calendar.getInstance(Locale.CHINA);
    System.out.println("原始    :"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.DAY_OF_MONTH,1);// 当月第一天
    System.out.println("当月第一天:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    //roll不会进位
    calendarT.roll(Calendar.DATE,-1);
    System.out.println("roll -1:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));
    calendarT.set(Calendar.DAY_OF_MONTH,1);// 当月第一天
    calendarT.add(Calendar.DATE,-1);
    //add产生进位
    System.out.println("add -1:"+DATETIME_FORMATER_WITHWEEK.format(calendarT.getTime()));

    //output:原始    :2015-04-16 星期四
                当月第一天:2015-04-01 星期三
                roll -1:2015-04-30 星期四
                add -1:2015-03-31 星期二
</code></pre>

<p>最后还是需要说明一点，获取当前时间指的是当前本地时间对应的UTC时间，和时区没有关系！有点绕，没关系看代码：</p>

<p>例子4：</p>

<pre><code>Calendar calendar1 = Calendar.getInstance(Locale.CHINA);
    Calendar calendar2 = Calendar.getInstance(Locale.GERMAN);
    System.out.println(calendar1.getTimeInMillis());
    System.out.println(calendar2.getTimeInMillis());

    //output:
        1429115150117
        1429115150117
</code></pre>

<p>最后贴一个日期处理开源库：<a href="https://github.com/JodaOrg/joda-time"><strong>joda-time</strong></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码(二)之JsonReader和JsonWriter]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li/"/>
    <updated>2015-01-10T14:17:21+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li</id>
    <content type="html"><![CDATA[<p>前文介绍了<code>Gson</code>对于<code>Json</code>规范中的类型进行了抽象定义，本文将来介绍<code>stream</code>包中的源码，这一块是<code>Gson</code>的核心代码之一。Gson中的JsonReader和JsonWriter抄自android.util包中的两个类，只是把其中的上下文栈由ArrayList换成了数组，提高了效率。这两个类为Json序列化和反序列化提供了基本接口。</p>

<!--more-->


<h1>反序列化&mdash;JsonReader</h1>

<h2>StringPool&ndash;(Flyweight Pattern)</h2>

<p>在Stream包中提供了一种针对String的优化处理，可以减少内存中String对象的个数，途径就是通过StringPool来对字符串进行复用。需要注意的是，在Java中字符串对象是不能被修改的，这也是这个Pool能正常工作的重要原因。StringPool原理和HashMap一模一样，通过一个2的n次方(512)作为数组的长度，字符串的hascode计算方式和String中的一致。为了使得hashcode分布分散一点，同样使用hashmap的补偿hash函数对hashcode进行处理，这一块的具体优化处理可以关注以后的HashMap源码分析。</p>

<h2>深度优先的解析策略</h2>

<p>Gson解析Json字符采用的是深度优先策略，下面是一个简单解析的栗子：</p>

<pre><code>[
&lt;!--数组中每一个对象为一个message对象--&gt;
{
  "id": 912345678901,
  "text": "How do I read a JSON stream in Java?",
  &lt;!--geo是一个double类型的数组--&gt;
  "geo": null,
  &lt;!--user对象--&gt;
  "user": {
    "name": "json_newb",
    "followers_count": 41
   }
},
{
  "id": 912345678902,
  "text": "@json_newb just use JsonReader!",
  "geo": [50.454722, -104.606667],
  "user": {
    "name": "jesse",
    "followers_count": 2
  }
}
]
</code></pre>

<p>深度解析的逻辑如下，先找到这个json字符串的开始位置，本例中是<code>[</code>，此时我们知道这个json字符串是一个数组，下一步从第一个元素开始解析(一层循环)。读取下一个字符，<code>{</code>,可以知道第一个元素为对象。对于<code>{</code>开始的JsonObject，我们知道它其中的内容肯定是键值对的样式，那我可以读取下一个字符，而且它必须为<code>"</code>(属性名)，然后去读取属性值。ok，我们可以看到这是一种非常正常的解析逻辑，其实Gson的解析就是这么做的。</p>

<h2>数据抽象</h2>

<p>为了进行上面的解析过程，Gson中定义了两种数据类型：</p>

<h3>JsonToken(解析类型)</h3>

<p>由于Json定义规范的原因，我们在解析过程中只要解析到一个结构的第一个元素再联系上下文就可以推断这个结构的类型。JsonToken用来描述<code>Json</code>中的<code>'{','}','[',']','"'</code>,<code>NULL</code>,<code>number</code>，<code>boolean</code>,属性名和属性字符串值，其实JsonToken的基本上等于每一个结构的开头，其中<code>"</code>既可以表示一个属性名也可以表示一个属性就是一个String，这需要按照上下文来确定。
在<code>JsonReader</code>定义了一个属性<code>token</code>，用来存储<code>Json</code>串解析位置的下一个<code>JsonToken</code>。</p>

<h3>JsonScope(解析上下文)</h3>

<p>用来描述当前正在解析的位置所处的一个状态，为解析提供一个上下文做推断。比如，目前我们解析到了一个<code>{</code>字符，那么下一个字符串必须是空或者&#8217;&ldquo;&lsquo;，如此我们可以推断这个<code>"</code>肯定是一个JsonToken.Name(属性名)。此外，JsonScope还可以描述一个JsonArray或者JsonObject目前解析到的位置是否是第一个元素。<code>JsonScope</code>被存放在一个栈中，而且是成对出现。</p>

<pre><code> private JsonScope[] stack = new JsonScope[32];
 {
   push(JsonScope.EMPTY_DOCUMENT);  //静态初始化时push空Json文件到栈顶
 }
 需要注意的是，这里这个栈之只实现了一个push操作，并提供了动态增长，出栈操作只需要简单的简单的stacksize--
</code></pre>

<h2>JsonReader工作流</h2>

<p><code>JsonReader</code>的构造函数接受一个<code>Reader</code>的参数，它是一个<code>Json</code>串的<code>InputStream</code>包装出来的<code>Reader</code>。</p>

<p>对于这个上文<code>Json</code>文档的解析，<code>JsonReader</code>的理逻辑如下：</p>

<pre><code>List&lt;Message&gt; result = new ArrayList&lt;Message&gt;(); 
jsonReader.beginArray();   //找到数组
while(jsonReader.hasnext) {
    Message message = new Message();
    jsonReader.beginObject();   //开始数组中的对象
    while(jsonReader.hasnext) {
        String name = jsonReader.nextName();
        if(name.equals("id")) {
            message.setId(jsonReader.nextString());
        }else if(name.equals("text")) {
            message.setText(jsonReader.nextString());
        }else if(name.equals("geo")&amp;&amp;jsonReader.peek()!=NULL) {
             List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();
             jsonReader.beginArray();
             while(jsonReader.hasnext()) {
                list.add(jsonReader.nextDouble());
             }
             JsonReader.endArray();
        }
        jsonReader.beginObject();
       .....开始解析User对象......
    }
    result.add(message);
}
</code></pre>

<h3>一些函数的解释</h3>

<h4>begin和 end系列函数</h4>

<p>其实这两个函数只是从业务的角度出发，封装了一下，实际两个函数都是调用<code>except(JsonToken)</code>，作用是寻找<code>json</code>字符串中的下一个<code>JsonToken</code>。以<code>beginObject()</code>函数来说，它直接调用<code>except(JsonToken.BEGIN_OBJECT)</code>。</p>

<pre><code>private void expect(JsonToken expected) throws IOException {
peek();         //找到下一个JsonToken，赋值给JsonReader的token属性
if (token != expected) {  //判断下一个Token是否等于指定的Token类型
  throw new IllegalStateException("Expected " + expected + " but was " +        peek() + " at line " + getLineNumber() + " column " +       getColumnNumber());
}
advance();  //下一步操作
}
</code></pre>

<h4>peek函数</h4>

<p>peek函数是JsonReader中最重要的函数，它的主要作用是进行上下文的判断，判断下一个JsonToken的读取方法。</p>

<p>下面看一下<code>peek()</code>函数的实现：</p>

<pre><code>public JsonToken peek() throws IOException {
//之前解析出来的token还没有被消费，直接取回
if (token != null) {
  return token;
}
//查看栈顶的JsonScope，这里可以看到JsonScope就是一个上下文的角色
switch (stack[stackSize - 1]) {
case EMPTY_DOCUMENT:    //json文档的开始 
  if (lenient) {    //json防止攻击引入的前导，防止跨域攻击
    consumeNonExecutePrefix();
  }
  stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;   //注意这里不是push而是直接替换栈顶元素
  JsonToken firstToken = nextValue();   //返回流中的下一个开始JsonToken，在上个例子中就是'['，也就是这里返回的是一个JsonToken.BEGIN_ARRAY,这个值还会被保存在token属性中
  if (!lenient &amp;&amp; token != JsonToken.BEGIN_ARRAY &amp;&amp; token != JsonToken.BEGIN_OBJECT) {   //一个json文档开始无非就是一个对象或者数组
    throw new IOException("Expected JSON document to start with '[' or '{' but was " + token
        + " at line " + getLineNumber() + " column " + getColumnNumber());
  }
  return firstToken;
case EMPTY_ARRAY:
    //目前处于一个数组中，但是还没有开始读取任何数据
  return nextInArray(true);
case NONEMPTY_ARRAY:
  return nextInArray(false);
case EMPTY_OBJECT: //目前处于一个JsonObject中但是还没有读取任何数据
  return nextInObject(true);
case DANGLING_NAME: //目前处于一个属性名的位置
  return objectValue();
case NONEMPTY_OBJECT:
  return nextInObject(false);
case NONEMPTY_DOCUMENT:
    //当前处于一个文档的解析上下文中，可以理解为根元素下一级的环境
  int c = nextNonWhitespace(false);
  if (c == -1) {
    return JsonToken.END_DOCUMENT;
  }
  pos--;
  if (!lenient) {
    throw syntaxError("Expected EOF");
  }
  //找下一个JsonToken
  return nextValue();
case CLOSED:
  throw new IllegalStateException("JsonReader is closed");
default:
  throw new AssertionError();
}
}
</code></pre>

<h4>nextIn**()</h4>

<p> 提供了数组、JsonObject的解析方法。</p>

<h4>nextValue()</h4>

<pre><code>找下一个JsonToken

private JsonToken nextValue() throws IOException {
int c = nextNonWhitespace(true);    //找到当前解析位置之后的第一个非空白字符
switch (c) {
case '{':
  push(JsonScope.EMPTY_OBJECT);   //进入一个JsonObject
  return token = JsonToken.BEGIN_OBJECT;

case '[':
  push(JsonScope.EMPTY_ARRAY);   //进入一个数组
  return token = JsonToken.BEGIN_ARRAY;
  //以上两种情况说明是一个新的结构的开始，所以需要pushJsonScope到栈中
case '\'':
  checkLenient(); // fall-through
case '"':
  //代表一个Json字符串值
  value = nextString((char) c);  //找到两个引号之间的String值
  return token = JsonToken.STRING;

default:
  pos--;
  return readLiteral();
}
}
</code></pre>

<h3>JsonReader总结</h3>

<p>JsonReader可以看作一个最基本的Json解析的接口，JsonReader中通过一个上下文来保存当前解析的环境，通过next**系列函数来获取下一个JsonToken。</p>

<h1>序列化&ndash;JsonWriter</h1>

<p>理解了JsonReader的源码之后，再来看Writer就相对来说简单多了。现在我们有一个数组，List<Message>，它的值就如上面的例子，那如何序列化呢?</p>

<pre><code>public void writeJsonStream(OutputStream out, List&lt;Message&gt; messages) throws IOException {
      JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
      writer.setIndent("\t");           //设置每一行的缩进
      writeMessagesArray(writer, messages);
      writer.close();
    }

    public void writeMessagesArray(JsonWriter writer, List&lt;Message&gt; messages) throws IOException {
      writer.beginArray();   //[
      for (Message message : messages) {
        writeMessage(writer, message);
      }
      writer.endArray();
    }

    public void writeMessage(JsonWriter writer, Message message) throws IOException {
      writer.beginObject(); //{
      writer.name("id").value(message.getId()); // "id":23435356
      writer.name("text").value(message.getText()); //"text":"dflsfldsfljd"
      if (message.getGeo() != null) {
        writer.name("geo");
        writeDoublesArray(writer, message.getGeo());
      } else {
        writer.name("geo").nullValue();
      }
      writer.name("user");
      writeUser(writer, message.getUser());
      writer.endObject();
    }

    public void writeUser(JsonWriter writer, User user) throws IOException {
      writer.beginObject();
      writer.name("name").value(user.getName());
      writer.name("followers_count").value(user.getFollowersCount());
      writer.endObject();
    }

    public void writeDoublesArray(JsonWriter writer, List&lt;Double&gt; doubles) throws IOException {
      writer.beginArray();
      for (Double value : doubles) {
        writer.value(value);
      }
      writer.endArray();
    }
</code></pre>

<h2>JsonWriter中的函数</h2>

<p>   事实上，可以看到JsonWriter的工作和JsonReader刚好相反，两个类的对json字符串的处理方式也基本相同。下面说一些业务流程中较为重要的方法。</p>

<h3>beginArray and beginObject</h3>

<p>开始向流中写入一个数组或者JsonObject的开始，注意，这里不仅仅是写入一个<code>[</code>或者一个<code>{</code>这么简单，首先会调用<code>writeDeferredName</code>方法，它的主要功能是如果这个开始的JsonElement是JsonObject中的一个属性，那么它的前面肯定有一个和上一个元素的分割符号和一个名字。</p>

<h3>endArray and endObject</h3>

<p>结束一个数组和对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMa效率分析]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/09/hashmaxiao-lu-fen-xi/"/>
    <updated>2015-01-09T11:00:58+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/09/hashmaxiao-lu-fen-xi</id>
    <content type="html"><![CDATA[<p>先填个link到这里吧：<a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function">http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function</a></p>

<p><a href="http://pengranxiang.iteye.com/blog/543893">http://pengranxiang.iteye.com/blog/543893</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码分析(一)之Json结构抽象和注解使用]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi/"/>
    <updated>2015-01-06T22:31:27+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<p>XML和Json作为最常用的两种网络传输格式而被广泛使用，XML在早期数据传输中作为首选，但是近年来Json以其轻量级和更容易编写和解析而越来越流行，Gson作为google的一个开源Json解析框架提供了稳定和快速解析的功能，可以读读它的源代码了解一番。</p>

<!--more-->


<p>说到Gson，其实它无非就是做两个工作，序列化(Object&mdash;>JsonString)和反序列化(JsonString&mdash;>Object)，后文所说的<em>两个方向</em>从Object到String和String到Object的两个方向。可想而知，对于序列化来说，是较为容易的工作，而对于反序列化即Json解析才是Gson的重头戏。既然是对Json字符串的解析，那么少不了对Json字符串中的结构进行抽象。</p>

<h2>Json抽象类</h2>

<h3>JsonElement</h3>

<p>这是Json中元素的基类，它只提供了若干个类型判断的接口，简单判断这个Json元素的类型。以下几个类型都是它的子类。</p>

<h4>1、JsonObject</h4>

<p>包含多个JsonElement的集合，它在Json中对应这种类型的数据：</p>

<pre><code>{
    "count":100,
    "users":[],
    "paging":{
        "offset":0,
        "limit":10,
        "hasMore":true
    }
}
</code></pre>

<p>这个data是一个典型的JsonObject，它以<code>{</code>开头，其中包含了一些类似数值，数组，对象等其他JsonElement的内容。<strong>其实每一个Json字符串的根节点都是一个JsonObject或者JsonArray。</strong></p>

<p>JsonObject提供了比较多的方法来得到Json中的信息，addProperty()函数可以在当前Json节点下新建子结点。</p>

<h4>2、JsonArray</h4>

<p>JsonArray也表示JsonElement的集合，注意：<strong>Json中的数组并不要求所有的数据类型都一样</strong>。</p>

<pre><code>    [true,"hello"] //JsonArray,包括一个boolean和一个hello类型。
</code></pre>

<p>需要讨论的是JsonArray和JsonObject的区别是什么？从集合的角度来说，JsonObject中的JsonElement是无序的，而JsonArray中的集合元素是有序的，从直观感受来说，你可以通过下标来引用JsonArray中的元素，而JsonObject是通过键值对的方式来访问的,<code>get("name")---&gt;value</code>。</p>

<h4>3、JsonPrimitive</h4>

<p>对应Json中的基本类型，比如boolean，int，当然提供了基本类型和包装类的自动替换。</p>

<pre><code>"count":100
</code></pre>

<h4>4、JsonNull</h4>

<p>空，对应null</p>

<pre><code>"person":null
</code></pre>

<p>以上就是Gson对应Json结构的封装。</p>

<h3>注解-Annotations</h3>

<h4>Expose</h4>

<p>在对象进行序列化和反序列化的过程中，我们可以通过注解来屏蔽某一些字段。这个注解默认有两个参数，<code>serialize</code>和<code>deserialize</code>都是默认true。如果设置为false，表示这个序列化(反)的过程中，这一个属性不需要进行处理。</p>

<p>通过Expose标注的属性在直接<code>new Gson()</code>的情况下不能生效，我们必须通过<code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>来创建一个可以识别Expose注解的Gson。</p>

<p>小小的吐槽一把，这个地方的使用确实不太方便，举个栗子，一般来说，我们进行序列化的时候都是希望某一个属性不会序列化到Json字符里面(反之亦然)，所以这里的一般思维是我要去处理这些特殊的属性。而如果你想通过Expose来去掉10个属性中的某一个，对不起，10个属性你都需要加上<code>@Expose</code>,然后对你想要处理的那个属性的Expose注解增加false参数，简直就是坑爹。。。。</p>

<pre><code>//我想让Person类在序列化时，不去序列化password，是不是很坑爹？
class Person {
    @Expose
    private String userName;
    @Expose (serialize = false)
    private String passWord;
}
</code></pre>

<p>此外，和java本身的序列化一样，如果一个属性设置为<code>transient</code>或者<code>static</code>,那么两个序列化的两个方向上都会屏蔽掉这个属性，虽然比Expose简单，但是不够灵活。</p>

<h4>SerializedName</h4>

<p>这个注解使用较多，它会改变两个方向上这个属性的名称，在序列化是，JsonElement的键值会被替换成这个名字；解析时，Json中键值为这个名字的JsonElement会赋值给被注解的属性。</p>

<pre><code>class Person {

@SerializedName(value = "A")
private int a ＝ 1;
private int b = 2;
}

//{"A":1,"b":2}  这个Json字符串和前面的Person等价
</code></pre>

<p>它使用场景最多的地方就是比如后端返回的json中的名称和我们定义的model类名称不一样时使用。</p>

<h4>Since 和 Until</h4>

<p>我们可以对我们的Model类进行序列化(两个方向)的版本控制，Since和Until刚好是两个相反的意义。</p>

<p>例子：</p>

<pre><code>class Person {
    @Since(value = 1.0)     //GsonBuilder指定版本要从1.0开始的Gson才能解析
    private int a = 1;

    @Until(value = 1.5)   //GsonBuilder指定版本到1.5的Gson都可以解析，超过了不能解析
    private int b = 2;
}
</code></pre>

<p>和Expose一样，要想Gson识别这两个注解，同样需要通过GsonBuilder.setVersion(double).create()来实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ActionBar]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/23/android-actionbar/"/>
    <updated>2014-12-23T10:58:00+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/23/android-actionbar</id>
    <content type="html"><![CDATA[<p>ActionBar作为Android3.0系统引入的一个重要的android app的风格，了解它的使用方法是每一个android开发者都必须要掌握的，本文主要基于android官方文档，对一些不常用的内容进行了删减，整理而成。</p>

<!--more-->


<p>说起3.0以后的ActionBar，其实在做3.0以前开发的童鞋应该有印象，Android提供了一个TitleBar，只不过默认的TitleBar只能显示一个标题和一个图标。它的样子大概如下：<br />
<img src="http://androidpeople.files.wordpress.com/2009/12/withicon.jpg" alt="" /></p>

<p>如果需要自己定义一个更加炫酷的Titlebar,比较麻烦，可以参考这篇文章：<a href="http://www.cnblogs.com/a284628487/archive/2013/06/07/3125265.html"><strong>自定义TitleBar</strong></a></p>

<p>ActionBar是TitleBar的增强版本，主要包括四个部分：</p>

<ol>
<li>为app提供一个唯一图片标识和导航的button,如果当前页面不是应用的首页，应该在app icon的左边添加返回的剪头。</li>
<li>切换界面上显示的view，官方名称叫view control。</li>
<li>放置一些显式的按钮，长按会显示它的title</li>
<li>放置一个action overflow</li>
</ol>


<p>对应如下图片：</p>

<p><img src="https://developer.android.com/design/media/action_bar_basics.png" alt="" /></p>

<p>正常的ActionBar会占据一定的屏幕空间，在ActionBar显示或者隐藏时，屏幕中的数据都会重绘去适应。如果我们需要ActionBar浮动在内容上面，可以将<code>windowActionBarOverlay</code>属性设置为true。</p>

<h2>增加ActionBar的Item</h2>

<p>在android菜单中曾经提到如何在ActionBar中增加菜单项，这里不再赘述。这里补充一个小的case：</p>

<p> 在ActionBar上显示的item也可以同时显示icon和title，当然前提是ActionBar的空间富余。通过在showAsAction中增加withText。</p>

<h2>分离的ActionBar(split)</h2>

<p>在分辨率不大的设备上，如果有足够多的Item需要显示，可能面临着屏幕宽度不够而显示不了那么多的Icon。分离ActionBar中的logo和菜单项，将菜单项移动到屏幕的下面，如图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-splitaction@2x.png" alt="" /></p>

<p>如果需要系统处理，那么我们需要指定属性：<code>uiOptions="splitActionBarWhenNarrow"</code>，但是如果需要支持低版本，我们可以这样写：</p>

<pre><code>    &lt;manifest ...&gt;
        &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
            &lt;meta-data android:name="android.support.UI_OPTIONS"
               android:value="splitActionBarWhenNarrow" /&gt;
        &lt;/activity&gt;
    &lt;/manifest&gt;
</code></pre>

<h2>ActionBar的导航button</h2>

<p>如果设置ActionBar.setDisplayHomeAsUpEnable(true),会产生一个导航按钮，如图所示：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-up.png" alt="" /></p>

<p>这个按钮和系统的back按键的区别在于，系统的back键有时候仅仅是为了返回到屏幕的上一次状态，而点击这个导航键就会返回到上一次的界面。
如果仅仅set这个导航键可见，它并不会响应任何操作，我们需要手动去指定点击这个导航键将会打开那个Activity，有两种方法可以来指定：</p>

<ol>
<li>在Menifest文件中通过activity的parentActivityname属性指定，当然这个属性是4.1加入的，如果要兼容之前的版本，可以通过meta的方式来做到。</li>
<li>在Activity中复写getParentActivityIntent，可以指定在app内导航的Intent。在别的应用中打开app，可以通过复写onCreateNavigateUpTaskStack来实现。</li>
</ol>


<p>注意，在support v7包中的actionbarActivity中，对以上提供了默认实现。</p>

<h2>ActionView</h2>

<p>actionview是在点击action button之后，一个显示出来的交互view,如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-searchview@2x.png" alt="" /></p>

<p>可以通过Menu item的<code>actionViewClass</code>来指定一个widget。我们也可以直接自己指定一个自定义布局给Action button，只需要把layout的id赋值给<code>actionLayout</code>即可。</p>

<p>app要获取这个Action View中的一些事件，可以在onCreateOptionsMenu中通过<code>menuItem.getActionView()</code>来获得。</p>

<p>下面来说一个比较有意思的可折叠的actionview，前文可知，如果设置actionLayout，那么如果ActionBar上面空间足够时，会直接把这个自定义的layout显示出来，但是如果这个item被放到overflow里面去了呢？此时<code>showAction</code>中的一个属性<code>collapseActionView</code>的作用就会显示出来，这个属性的作用是：</p>

<p>如果这个action button被放到overflow中，点击后还是可以把它的actionview打开(可折叠)，如果不加这个属性，那么系统将不会打开actionview。如果是打开折叠的actionview，ActionBar会自动把导航剪头加上，并且清空ActionBar上面的action button(除去overflow按钮)，如下图：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_5B4AFB05-1AFC-4F4F-887F-304187E96E16.png" alt="" /></p>

<p>我们可以在<code>onCreateOptionsMenu</code>中  通过<code>MenuItemCompat.setOnActionExpandListener</code>来监听actionview的扩张事件。</p>

<h2>Action Provider</h2>

<p>上一节提到的actionview，它是直接在ActionBar上面展示出来，ActionProvider是在ActionBar上展示一个下拉的菜单，如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-shareaction@2x.png" alt="" /></p>

<p>创建一个Action provider可以通过指定给<code>android:actionProviderClass</code>属性一个ActionProvider即可。</p>

<h2>添加导航的tab</h2>

<p>这种方式已经不被推荐使用了，所以这里不做详细解释，使用它很简单。</p>

<h2>下拉导航</h2>

<p>下拉导航是在ActionBar的左边提供一个action provider类似的下拉框，可以使用在改变界面内容的频率不频繁的情况下可以使用Drop-down Navigation来进行切换选项的提供，如下图：</p>

<p><img src="http://developer.android.com/images/ui/actionbar-dropdown@2x.png" alt="" /></p>

<p>使用下拉导航有几个步骤：</p>

<ol>
<li>创建一个SpinnerAdapter，提供下拉项的布局</li>
<li>实现一个选择接口 <code>ActionBar.OnNavigationListener</code>，处理事件</li>
<li>在Activity的onCreate里面调用setnavigationMode()</li>
<li>actionbar.setListNavigationCallbacks(spinneradapter,mnavigationcallback),将1和2定义的东西传进去</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android之菜单]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan/"/>
    <updated>2014-12-19T17:19:36+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan</id>
    <content type="html"><![CDATA[<p>本文参考自官方文档：<a href="https://developer.android.com/guide/topics/ui/menus.html">https://developer.android.com/guide/topics/ui/menus.html</a></p>

<p>Android为了维护app之间一个统一的操作习惯，提供了Menus来处理用户和Activity之间的一些交互。但是在不同的系统版本上面推荐的Menu不一样。比如在android 3.0以下，由于Google会要求所有设备生产商提供一个菜单的实体键，所以在3.0一下菜单的主要弹出方式就是点击菜单实体键，弹出6个条目的菜单面板。在3.0以后，引入ActionBar，打开菜单行为转变成点击ActionBar上面的overflow按钮。这两种菜单面板的操作一般都是影响到整个app的操作。</p>

<!--more-->


<p>下图是3.0一下的Option Menu的样子：<br /></p>

<p><img src="https://developer.android.com/images/options_menu.png" alt="" /></p>

<p>这是3.0上的ActionBar的样子：</p>

<p><img src="https://developer.android.com/images/ui/actionbar.png" alt="" /></p>

<p>当然除了上面提到的菜单面板，Android还提供了上下文菜单(Context menu)和弹出菜单(Popup Menu)。尽管存在三种不同的菜单，但是Android提供了一个统一操作的API。</p>

<h2>在XML中定义菜单项</h2>

<p>Menu文件定义的位置在 res/menu目录下，而且顶层元素必须是Menu。在Menu中可以放置item和group，其中group又可以包含多个item。在group中的所有item都会共享某一些熟悉，主要是用来对group进行分类管理,比如设置某一类菜单项的可见。</p>

<p>多级菜单可以通过在item中嵌入Menu来现实。</p>

<h3>选项菜单</h3>

<p>前面已经说到，选项菜单在3.0前后版本存在一些差别。在Fragment和Activity中都可以创建选项菜单,系统会首先显示Activity中创建的item，然后按照fragment加入的顺序添加item。<strong>在3.0一下时，onCreateOptionsMenu是在点击菜单键时触发；在3.0以上，则是在Activity创建时就会调用。</strong></p>

<p>响应点击事件，可以在onOptionsItemSelected中进行。注意这个事件处理函数需要返回一个boolean值。如果已经处理了这次点击需要返回true，否则直接调用super.onOptionsItemSelected()(返回fasle)。这个事件的处理流程是，事件先被送到Activity，然后按照先进先达的顺序，直至莫一个fragement处理了这次点击或者所有的fragment都已经遍历了。</p>

<p>可以在菜单的item中指定<code>android:onClick</code>，这个点击事件的处理函数必须是Activity中签名为public 并且接受一个MenuItem的参数。</p>

<p><strong>更新菜单中的选项</strong>，我们可以通过onCreateOptionsMenu来创建菜单项，但是如果想在运行时改变菜单中的选项，可以重写onPrepareOptionsMenu方法来实现。在3.0以下，这个方法会在菜单键每次按下的时候触发；在3.0以上，由于ActionBar是一直显示的，所以我们如果需要改变菜单，可以主动调用<code>invalidateOptionsMenu()</code>,然后系统会去走onPrepareOptionsMenu。</p>

<h3>上下文菜单</h3>

<p>Contextual Menu主要多用于和界面特别是AdapterView中的某一个item进行交互,通过长按控件来呼出一个Action Menu。如果说Option menu(Actionbar)上面的菜单选项是针对整个app的范围，那么Contextual Menu从名字就可以看出来是针对当前context范围内的操作。存在两种方式：</p>

<ul>
<li>floating context menu，通常在长按ListView中的某一项之后出现。</li>
<li>Contextual action mode，会显示出一个ActionBar，它是一种ActionMode的实现，在3.0系统以上才能使用。</li>
</ul>


<p>下图左边是floating context Menu，右边是Contextual action mode</p>

<p><img src="https://developer.android.com/images/ui/menu-context.png" alt="" /></p>

<h4>floating context menu</h4>

<p>floating context menu是3.0一下版本建议使用的，针对当前Context的一个操作面板，通过长按指定控件呼出。<strong>长按事件如果也被监听，那么会先执行长按事件，再执行onContextItemSelected。如果长按事件处理返回true，那么context Menu不会被呼出</strong>：</p>

<ol>
<li>通过Activity或者Fragment的registerForContextMenu,传入一个View，为它注册一个floating context menu</li>
<li>实现onCreateContextMenu，来创建Menu条目</li>
<li>实现onContextItemSelected处理选择某一个菜单的事件</li>
</ol>


<p>同样需要注意的是在处理事件时，也是由Activity最先接收，然后按照加入顺序分发到每一个Fragment。</p>

<h4>contextual action mode</h4>

<p>从上图可以看到Contextual action和ActionBar颇有几分相似，但是两者直接并无直接关联。在3.0一下版本中，我们需要使用support包中的兼容方案。
单个View使用步骤如下：</p>

<ol>
<li>实现ActionMode.CallBack，这里主要实现action mode的主要逻辑</li>
<li>在合适的时候通过Activity或者fragment的startSupportActionMode来进入一个contextaul action mode。</li>
</ol>


<p>在AdapterView中使用，步骤如下：</p>

<ol>
<li>实现AbsListView.MultiChoiceModeListener，其实这个玩意继承自ActionMode.CallBack，增加了onItemCheckedStateChanged函数，用来处理当AbsListView中某一项的选择状态改变时的操作。</li>
<li>通过设置AbsListView的MultiChoiceModeListener，注意，这里默认进入Action Mode的动作是长按某一个Item。</li>
</ol>


<h3>Popup Menu</h3>

<p>API level 11加入。在android中还提供了一种用来相对于界面上已经存在的一个控件的菜单，比如类似于ActionBar上面的overflow。</p>

<p><img src="https://developer.android.com/images/ui/popupmenu.png" alt="" /></p>

<p>使用Popup Menu的步骤如下：</p>

<ol>
<li>通过context和相对的View创建PopupMenu对象。</li>
<li>通过popupMenu对象来设置Menu的布局和监听事件函数。</li>
</ol>


<p><strong>需要注意的是PopupMenu弹出的位置是自适应的，主要看这个View在那个地方有空间，就会在哪个方向上面弹出来。</strong></p>

<h3>选择菜单项</h3>

<p>选择菜单和前面所提及的菜单类型不同，它仅仅是一种菜单项的表现形式。在本文之前提及的所有菜单中，每一个菜单项的呈现方式都是简单的文字(或者icon),如果我们要加入一种单选框或者复选框的效果，可以使用item的checkable属性。效果如下图：</p>

<p><img src="https://developer.android.com/images/radio_buttons.png" alt="" /></p>

<p>需要注意的是，在option Menu中，如果一个菜单项是以icon的方式显示出来，那么它将不会显示选择框。</p>

<p>我们亦可以通过group来为一组item设置选择条件，这才是它本来的意义。<code>android:checkableBehavior</code>可以设置成radio 或者checkbox或者none，默认应该是checkbox。
<strong>选择菜单项是不能保存状态的，如果app退出，下次再进入状态就不存在了。</strong></p>

<h3>意图菜单项</h3>

<p>如果我们需要在菜单项中通过Intent启动另外一个Activity，Menu提供了专门的类型来处理，这就是Intent Options。而且意图菜单项还可以在系统中解析这个Intent是否能够被Activity了解，如果系统中没有Activity能够接受这个Intent，那么这个意图菜单项将不会展示出来。使用步骤如下：</p>

<ol>
<li>在定义的Intent中增加一个category：<code>CATEGORY_ALTERNATIVE and/or CATEGORY_SELECTED_ALTERNATIVE</code></li>
<li>调用Menu.addIntentOpions()。</li>
</ol>


<p>addIntentOptions方法返回增加的item数目，所以通过Intent解析的item都会被加入菜单中。<strong>这个菜单项的item title就是intent-filter的android:label,icon是application icon</strong></p>

<p>感觉这个东东和settings等系统模块一样，在中国开发者的眼中根本不会去用它，所以老外才会感叹中国做的app怎么这么难用，每个应用的风格都不一样。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpClient]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/16/httpclient/"/>
    <updated>2014-12-16T12:20:26+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/16/httpclient</id>
    <content type="html"><![CDATA[<p>Http协议是在开发中使用最多的网络协议，大部分的网络接口都是通过Http来设计。在Android中提供了两种Http客户端，HttpClient和HttpUrlConnetion。其中后者在低版本存在某些问题，但是HttpClient尽管功能强大，但使用麻烦，接口众多，本文主要是简单介绍HttpClient中使用的一些概念。</p>

<!--more-->


<h2>Request URI</h2>

<p>URI用来表示一个HTTP请求的目标，它由protocol scheme,host名字,port(可选)，resource path,query(可选)和fragment(可选)组成。对应的例子就是：<br />
&ldquo;<a href="http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=">http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=</a>&rdquo;
<br />
apache的HttpClient中(注意，这里将这个apache对于Http的客户端实现的类库统称为HttpClient),提供了URIBuilder来创建一个request URI。</p>

<h2>HttpRequest</h2>

<p>HttpRequest类对应于Http协议中的request line，它主要包括的信息有：Http方法、请求的URI和Http的版本号。</p>

<h2>HttpResponse</h2>

<p>Httpresponse对应于Http协议中的返回中的第一行，包括：协议版本，状态码和状态码的解释。</p>

<h2>HttpMessage</h2>

<p>对应于Http的请求头，所以HttpRequest和HttpResponse都实现了HttpMessage，因为在其中都有Http Head。</p>

<h2>Http entity</h2>

<p>一个Http请求或者响应实际传输的内容，对于请求来说，HTTP规范定义了两种请求方法需要entity：post和put；HTTP期望所有的response都能包含一个entity，当然如果在Head中包含一些出错信息就另当别论。<br />
在HttpClient中依据来源不同，将entity分为三类：</p>

<ul>
<li>streamed：从一个传输流中获得，一般是来自http连接。不可重复。</li>
<li>self-contained：存在内存中，独立于http连接。可以重复。</li>
<li>wrapping：从其他的HttpEntity中获得。依赖于获取的类。</li>
</ul>


<p>注意：以上所说的重复不重复，指的是可不可以多次读取其中的内容，只有self-contained类型的可以重复读取。</p>

<h3>读取entity</h3>

<p>推荐使用流的方式来操作entity中的内容,getContent或者writeTo。HttpClient提供了一个entityUtils类来直接将entity转化成String或者byte数组。不建议使用entityUtils，除非这个响应来自一个可信的server同时可以知道它的长度有限。</p>

<p>如果一个entity需要被多次读取，我们可以使用一个BufferedHttpEntity来将entity缓存至内存中。</p>

<h3>构造entity</h3>

<p>对于post或者put这种可以在请求中附带entity的request(entity enclosing request)，HttpClient提供了多种针对不同数据类型的Entity，比如StringEntity、ByteArrayEntity、InputStreamEntity和FileEntity。</p>

<p>为了模拟HTML表单提交的Post请求，我们可以通过对Post请求设置一个UrlEncodedFormEntity给Post的entity。</p>

<h2>释放资源</h2>

<p>在Http请求得到response之后，我们需要释放资源，可以选择释放content Stream 和 response自身。两者的区别在于：contentStream.close()会保留底层的连接，而response则会关闭整个连接。如果对一个response 返回的内容我们只需要其中一部分的内容，而不需要剩余的部分，可以通过直接关闭response。</p>

<p>注意，我们可以在一个HttpClient执行的request设置一个response handler，然后在handleResponse中处理数据，这样做的好处就是HttpClient会自动去维护资源的释放。</p>

<h2>异常处理</h2>

<p>在HttpClient中，有两类异常：I/O Exception 和 HttpException。前者不是致命的错误，而且也可以恢复，而后者则相反。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[geniousadapter,快速构建Adapter]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter/"/>
    <updated>2014-12-14T20:28:32+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chuyun923/ingenious-adapter"><strong>geniousadapter</strong></a><br/>
前面的话：本项目的原型是<a href="https://github.com/JoanZapata/base-adapter-helper">QuickAdapter</a>，它们的思路基本一致，但本项目的优势在于：</p>

<ul>
<li>支持AdapterView存在多个layout类型</li>
<li>可配置图片加载缓存库</li>
</ul>


<!--more-->


<p>在使用AdapterView时，我们需要使用Adapter来绑定数据源和AdapterView中的每一项数据。通常我们继承自BaseAdapter,然后重写四个方法：</p>

<pre><code>public int getCount()

public Object getItem(int position) 

public long getItemId(int position)

public View getView(int position, View convertView, ViewGroup parent) 
</code></pre>

<p>其中主要的逻辑实现在getView，这个方法主要完成两步操作：1、生成(或者从缓存中取出)当前item对应的ItemView；2、将数据和ItemView绑定。通常，由于AdapterView支持缓存机制(如ListView)，我们通过一个Holder来避免每一次getView重复的findViewById。</p>

<pre><code>private static class Holder {
    TextView tv_name;
    ImageView iv_avatar;
    .....
}

public View getView(int position, View convertView, ViewGroup parent) {
    Holder hodler = null;
    if(converView==null) {
        holder = new Holder();
         convertView = LayoutInflater.from(context)
            .inflate(layoutId, parent, false);
        holder.tv_name = (TextView) findViewById(R.id.tv_name);
        holder.iv_avatar = (ImageView) findViewById(R.id.iv_avatar);
        ...
        //下次就不需要findViewById了
        covertView.setTag(holder);
    }

    holder =(Holder) convertView.getTag();
    holder.tv_name.setText(***);
    holder.iv_avatar.set(***);
} 
</code></pre>

<p>以上就是BaseAdapter的典型用法，那么在项目里面的所有Adapter都存在Holder，并且都存在<code>holder.properties = (ViewType) findViewById(id)</code>的重复代码。可以想象一下，如果Holder中有比较多的属性，特别是如果一个AdapterView具有多个不同类型的layout，那么也需要多个不同Holder，getView将会特别复杂。<br />
<strong>geniousadapter</strong>对getView进行了一层封装，并将getView函数的两部分功能进行拆分，自动完成了生成ItemView和Holder的过程，通过一个抽象方法covert让子类实现数据绑定。子类需要实现两个抽象方法：</p>

<pre><code>  /**
  * 通过AdapterHolder填充view的属性,这个函数主要完成数据绑定的过程，使用方法：
  * holder.setText(R.id.tv_name,"张三").setText(R.id.tv_nickName,
  * "三儿").setImageResource(R.id.iv_avatar,R.drawable.ic_user_avatar);
  * holder 
  * item 当前item需要绑定的数据
  */
  protected abstract void convert(AdapterHolder holder, T item,int viewType);

 /**
  * layoutid至数据类型的映射,插入顺序对应itemviewtype
  * @return
  */
  protected abstract int[] assignLayoutIDs();
</code></pre>

<p><code>holder.setImageUrl(int,imageUrl)</code>可以通过使用者自己定义远程图片加载的方式。用户可以自己实现加载图片或者使用第三方图片加载缓存库，其接口如下：</p>

<pre><code>public interface ImageLoader {

public void load(ImageView imageView,String imageUrl);

//placeResId  默认图resid
public void load(ImageView imageView,String imageUrl,int placeResId);
}
</code></pre>

<p>比如我们可以使用picasso来完成加载图片的功能，在合适的位置来指定：</p>

<pre><code>DefaultAdapterConfig.setImageLoader(new ImageLoader() {
    @Override
    public void load(ImageView imageView, String imageUrl) {
        picasso.load(imageUrl).into(imageView);
    }

    @Override
    public void load(ImageView imageView, String imageUrl, int placeResId) {
        picasso.load(imageUrl).placeholder(placeResId).into(imageView);
    }
});
</code></pre>

<p>总结：genious Adapter可以使用户在getView方法中无需关注每一项ItemView生成的细节，而只需要处理数据绑定的逻辑即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的泛型方法]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa/"/>
    <updated>2014-12-04T16:36:56+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>在通过反射获取类的私有域时希望写一个方法，可以指定一个域的名字和域的类型，可以返回指定类型的对象。</p>

<!--more-->


<p>方法实现如下：</p>

<pre><code>/**
 * 获取一个类的私有域
 * @param fromClass 私有域所在的类
 * @param fieldName 域的名字
 * @param &lt;T&gt;
 * @return
 */
private &lt;T&gt; T getPrivateFiled(Class&lt;T&gt; fromClass, String fieldName) {
    T result = null;
    try {
        Field field = fromClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        result = (T) field.get(this);
    } catch (NoSuchFieldException e) {
    } catch (IllegalAccessException e) {
    }
    return result;
}
</code></pre>

<p>泛型方法的结构如下：<br />
<img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_java%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95.png" alt="image" />
<br />
值得说明的是，声明泛型方法首先需要在返回值前面用<code>&lt;T&gt;</code>表明这是一个泛型方法，持有一个泛型。当然，一般来说我们需要在参数中传入一个class对象，不然函数的泛型没有任何意义了。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress写博客的个性配置]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/22/first/"/>
    <updated>2014-11-22T14:09:59+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/22/first</id>
    <content type="html"><![CDATA[<!--more-->


<h2>配置_config.yml</h2>

<ul>
<li>在首页只显示部分文章，而不是全文，可以通过<code>_config.yml</code>来设置，该文件中使用键值对来存储，<strong>键名: value</strong>中间的空格不能少。<code>excerpt_separator</code>，摘要标志，如果一篇文章中出现了这个标志，表明此文章在首页现实时需要采用摘要的模式，默认为<code>&lt;!--more--&gt;</code>。<code>excerpt_link</code>为读更多的link显示的文字，我们可以设置为&#8221;阅读全文&#8221;。</li>
</ul>


<h2>新建博客</h2>

<ul>
<li><p>设置使用指定的编辑器自动打开新建的blog。现在每次新建一篇blog，都要跑到<code>/source_posts</code>里面去打开，先到Rakefile文件里面的<code>## -- Misc Configs -- ##</code>注释下，在<code>server_port</code>下面新增一个键值对<code>editor = "open -a Mou"</code>。<br />
然后在文件中找到<code>new_post</code>任务，在最后一个<code>end</code>之前添加如下代码：</p>

<pre><code>  if #{editor}
      system "#{editor} #{filename}"
  end
</code></pre>

<p>如此一来，每次<code>rake new_post</code>都会自动打开Mou编辑器。</p></li>
<li><p>preview的时候自动打开浏览器预览。还是在<code>Rakefile</code>中，找到preview任务，加入代码</p>

<pre><code>  system "sleep 2; open http://localhost:#{server_port}/"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
