<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[楚云之南]]></title>
  <link href="http://chuyun923.github.io/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2014-12-23T10:09:11+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android之菜单]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan/"/>
    <updated>2014-12-19T17:19:36+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan</id>
    <content type="html"><![CDATA[<p>本文参考自官方文档：<a href="https://developer.android.com/guide/topics/ui/menus.html">https://developer.android.com/guide/topics/ui/menus.html</a></p>

<p>Android为了维护app之间一个统一的操作习惯，提供了Menus来处理用户和Activity之间的一些交互。但是在不同的系统版本上面推荐的Menu不一样。比如在android 3.0以下，由于Google会要求所有设备生产商提供一个菜单的实体键，所以在3.0一下菜单的主要弹出方式就是点击菜单实体键，弹出6个条目的菜单面板。在3.0以后，引入ActionBar，打开菜单行为转变成点击ActionBar上面的overflow按钮。这两种菜单面板的操作一般都是影响到整个app的操作。</p>

<!--more-->


<p>下图是3.0一下的Option Menu的样子：<br /></p>

<p><img src="https://developer.android.com/images/options_menu.png" alt="" /></p>

<p>这是3.0上的ActionBar的样子：</p>

<p><img src="https://developer.android.com/images/ui/actionbar.png" alt="" /></p>

<p>当然除了上面提到的菜单面板，Android还提供了上下文菜单(Context menu)和弹出菜单(Popup Menu)。尽管存在三种不同的菜单，但是Android提供了一个统一操作的API。</p>

<h2>在XML中定义菜单项</h2>

<p>Menu文件定义的位置在 res/menu目录下，而且顶层元素必须是Menu。在Menu中可以放置item和group，其中group又可以包含多个item。在group中的所有item都会共享某一些熟悉，主要是用来对group进行分类管理,比如设置某一类菜单项的可见。</p>

<p>多级菜单可以通过在item中嵌入Menu来现实。</p>

<h3>选项菜单</h3>

<p>前面已经说到，选项菜单在3.0前后版本存在一些差别。在Fragment和Activity中都可以创建选项菜单,系统会首先显示Activity中创建的item，然后按照fragment加入的顺序添加item。<strong>在3.0一下时，onCreateOptionsMenu是在点击菜单键时触发；在3.0以上，则是在Activity创建时就会调用。</strong></p>

<p>响应点击事件，可以在onOptionsItemSelected中进行。注意这个事件处理函数需要返回一个boolean值。如果已经处理了这次点击需要返回true，否则直接调用super.onOptionsItemSelected()(返回fasle)。这个事件的处理流程是，事件先被送到Activity，然后按照先进先达的顺序，直至莫一个fragement处理了这次点击或者所有的fragment都已经遍历了。</p>

<p>可以在菜单的item中指定<code>android:onClick</code>，这个点击事件的处理函数必须是Activity中签名为public 并且接受一个MenuItem的参数。</p>

<p><strong>更新菜单中的选项</strong>，我们可以通过onCreateOptionsMenu来创建菜单项，但是如果想在运行时改变菜单中的选项，可以重写onPrepareOptionsMenu方法来实现。在3.0以下，这个方法会在菜单键每次按下的时候触发；在3.0以上，由于ActionBar是一直显示的，所以我们如果需要改变菜单，可以主动调用<code>invalidateOptionsMenu()</code>,然后系统会去走onPrepareOptionsMenu。</p>

<h3>上下文菜单</h3>

<p>Contextual Menu主要多用于和界面特别是AdapterView中的某一个item进行交互,通过长按控件来呼出一个Action Menu。如果说Option menu(Actionbar)上面的菜单选项是针对整个app的范围，那么Contextual Menu从名字就可以看出来是针对当前context范围内的操作。存在两种方式：</p>

<ul>
<li>floating context menu，通常在长按ListView中的某一项之后出现。</li>
<li>Contextual action mode，会显示出一个ActionBar，它是一种ActionMode的实现，在3.0系统以上才能使用。</li>
</ul>


<p>下图左边是floating context Menu，右边是Contextual action mode</p>

<p><img src="https://developer.android.com/images/ui/menu-context.png" alt="" /></p>

<h4>floating context menu</h4>

<p>floating context menu是3.0一下版本建议使用的，针对当前Context的一个操作面板，通过长按指定控件呼出。<strong>长按事件如果也被监听，那么会先执行长按事件，再执行onContextItemSelected。如果长按事件处理返回true，那么context Menu不会被呼出</strong>：</p>

<ol>
<li>通过Activity或者Fragment的registerForContextMenu,传入一个View，为它注册一个floating context menu</li>
<li>实现onCreateContextMenu，来创建Menu条目</li>
<li>实现onContextItemSelected处理选择某一个菜单的事件</li>
</ol>


<p>同样需要注意的是在处理事件时，也是由Activity最先接收，然后按照加入顺序分发到每一个Fragment。</p>

<h4>contextual action mode</h4>

<p>从上图可以看到Contextual action和ActionBar颇有几分相似，但是两者直接并无直接关联。在3.0一下版本中，我们需要使用support包中的兼容方案。
单个View使用步骤如下：</p>

<ol>
<li>实现ActionMode.CallBack，这里主要实现action mode的主要逻辑</li>
<li>在合适的时候通过Activity或者fragment的startSupportActionMode来进入一个contextaul action mode。</li>
</ol>


<p>在AdapterView中使用，步骤如下：</p>

<ol>
<li>实现AbsListView.MultiChoiceModeListener，其实这个玩意继承自ActionMode.CallBack，增加了onItemCheckedStateChanged函数，用来处理当AbsListView中某一项的选择状态改变时的操作。</li>
<li>通过设置AbsListView的MultiChoiceModeListener，注意，这里默认进入Action Mode的动作是长按某一个Item。</li>
</ol>


<h3>Popup Menu</h3>

<p>API level 11加入。在android中还提供了一种用来相对于界面上已经存在的一个控件的菜单，比如类似于ActionBar上面的overflow。</p>

<p><img src="https://developer.android.com/images/ui/popupmenu.png" alt="" /></p>

<p>使用Popup Menu的步骤如下：</p>

<ol>
<li>通过context和相对的View创建PopupMenu对象。</li>
<li>通过popupMenu对象来设置Menu的布局和监听事件函数。</li>
</ol>


<p><strong>需要注意的是PopupMenu弹出的位置是自适应的，主要看这个View在那个地方有空间，就会在哪个方向上面弹出来。</strong></p>

<h3>选择菜单项</h3>

<p>选择菜单和前面所提及的菜单类型不同，它仅仅是一种菜单项的表现形式。在本文之前提及的所有菜单中，每一个菜单项的呈现方式都是简单的文字(或者icon),如果我们要加入一种单选框或者复选框的效果，可以使用item的checkable属性。效果如下图：</p>

<p><img src="https://developer.android.com/images/radio_buttons.png" alt="" /></p>

<p>需要注意的是，在option Menu中，如果一个菜单项是以icon的方式显示出来，那么它将不会显示选择框。</p>

<p>我们亦可以通过group来为一组item设置选择条件，这才是它本来的意义。<code>android:checkableBehavior</code>可以设置成radio 或者checkbox或者none，默认应该是checkbox。
<strong>选择菜单项是不能保存状态的，如果app退出，下次再进入状态就不存在了。</strong></p>

<h3>意图菜单项</h3>

<p>如果我们需要在菜单项中通过Intent启动另外一个Activity，Menu提供了专门的类型来处理，这就是Intent Options。而且意图菜单项还可以在系统中解析这个Intent是否能够被Activity了解，如果系统中没有Activity能够接受这个Intent，那么这个意图菜单项将不会展示出来。使用步骤如下：</p>

<ol>
<li>在定义的Intent中增加一个category：<code>CATEGORY_ALTERNATIVE and/or CATEGORY_SELECTED_ALTERNATIVE</code></li>
<li>调用Menu.addIntentOpions()。</li>
</ol>


<p>addIntentOptions方法返回增加的item数目，所以通过Intent解析的item都会被加入菜单中。<strong>这个菜单项的item title就是intent-filter的android:label,icon是application icon</strong></p>

<p>感觉这个东东和settings等系统模块一样，在中国开发者的眼中根本不会去用它，所以老外才会感叹中国做的app怎么这么难用，每个应用的风格都不一样。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpClient]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/16/httpclient/"/>
    <updated>2014-12-16T12:20:26+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/16/httpclient</id>
    <content type="html"><![CDATA[<p>Http协议是在开发中使用最多的网络协议，大部分的网络接口都是通过Http来设计。在Android中提供了两种Http客户端，HttpClient和HttpUrlConnetion。其中后者在低版本存在某些问题，但是HttpClient尽管功能强大，但使用麻烦，接口众多，本文主要是简单介绍HttpClient中使用的一些概念。</p>

<!--more-->


<h2>Request URI</h2>

<p>URI用来表示一个HTTP请求的目标，它由protocol scheme,host名字,port(可选)，resource path,query(可选)和fragment(可选)组成。对应的例子就是：<br />
&ldquo;<a href="http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=">http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=</a>&rdquo;
<br />
apache的HttpClient中(注意，这里将这个apache对于Http的客户端实现的类库统称为HttpClient),提供了URIBuilder来创建一个request URI。</p>

<h2>HttpRequest</h2>

<p>HttpRequest类对应于Http协议中的request line，它主要包括的信息有：Http方法、请求的URI和Http的版本号。</p>

<h2>HttpResponse</h2>

<p>Httpresponse对应于Http协议中的返回中的第一行，包括：协议版本，状态码和状态码的解释。</p>

<h2>HttpMessage</h2>

<p>对应于Http的请求头，所以HttpRequest和HttpResponse都实现了HttpMessage，因为在其中都有Http Head。</p>

<h2>Http entity</h2>

<p>一个Http请求或者响应实际传输的内容，对于请求来说，HTTP规范定义了两种请求方法需要entity：post和put；HTTP期望所有的response都能包含一个entity，当然如果在Head中包含一些出错信息就另当别论。<br />
在HttpClient中依据来源不同，将entity分为三类：</p>

<ul>
<li>streamed：从一个传输流中获得，一般是来自http连接。不可重复。</li>
<li>self-contained：存在内存中，独立于http连接。可以重复。</li>
<li>wrapping：从其他的HttpEntity中获得。依赖于获取的类。</li>
</ul>


<p>注意：以上所说的重复不重复，指的是可不可以多次读取其中的内容，只有self-contained类型的可以重复读取。</p>

<h3>读取entity</h3>

<p>推荐使用流的方式来操作entity中的内容,getContent或者writeTo。HttpClient提供了一个entityUtils类来直接将entity转化成String或者byte数组。不建议使用entityUtils，除非这个响应来自一个可信的server同时可以知道它的长度有限。</p>

<p>如果一个entity需要被多次读取，我们可以使用一个BufferedHttpEntity来将entity缓存至内存中。</p>

<h3>构造entity</h3>

<p>对于post或者put这种可以在请求中附带entity的request(entity enclosing request)，HttpClient提供了多种针对不同数据类型的Entity，比如StringEntity、ByteArrayEntity、InputStreamEntity和FileEntity。</p>

<p>为了模拟HTML表单提交的Post请求，我们可以通过对Post请求设置一个UrlEncodedFormEntity给Post的entity。</p>

<h2>释放资源</h2>

<p>在Http请求得到response之后，我们需要释放资源，可以选择释放content Stream 和 response自身。两者的区别在于：contentStream.close()会保留底层的连接，而response则会关闭整个连接。如果对一个response 返回的内容我们只需要其中一部分的内容，而不需要剩余的部分，可以通过直接关闭response。</p>

<p>注意，我们可以在一个HttpClient执行的request设置一个response handler，然后在handleResponse中处理数据，这样做的好处就是HttpClient会自动去维护资源的释放。</p>

<h2>异常处理</h2>

<p>在HttpClient中，有两类异常：I/O Exception 和 HttpException。前者不是致命的错误，而且也可以恢复，而后者则相反。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[geniousadapter,快速构建Adapter]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter/"/>
    <updated>2014-12-14T20:28:32+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chuyun923/ingenious-adapter"><strong>geniousadapter</strong></a><br/>
前面的话：本项目的原型是<a href="https://github.com/JoanZapata/base-adapter-helper">QuickAdapter</a>，它们的思路基本一致，但本项目的优势在于：</p>

<ul>
<li>支持AdapterView存在多个layout类型</li>
<li>可配置图片加载缓存库</li>
</ul>


<!--more-->


<p>在使用AdapterView时，我们需要使用Adapter来绑定数据源和AdapterView中的每一项数据。通常我们继承自BaseAdapter,然后重写四个方法：</p>

<pre><code>public int getCount()

public Object getItem(int position) 

public long getItemId(int position)

public View getView(int position, View convertView, ViewGroup parent) 
</code></pre>

<p>其中主要的逻辑实现在getView，这个方法主要完成两步操作：1、生成(或者从缓存中取出)当前item对应的ItemView；2、将数据和ItemView绑定。通常，由于AdapterView支持缓存机制(如ListView)，我们通过一个Holder来避免每一次getView重复的findViewById。</p>

<pre><code>private static class Holder {
    TextView tv_name;
    ImageView iv_avatar;
    .....
}

public View getView(int position, View convertView, ViewGroup parent) {
    Holder hodler = null;
    if(converView==null) {
        holder = new Holder();
         convertView = LayoutInflater.from(context)
            .inflate(layoutId, parent, false);
        holder.tv_name = (TextView) findViewById(R.id.tv_name);
        holder.iv_avatar = (ImageView) findViewById(R.id.iv_avatar);
        ...
        //下次就不需要findViewById了
        covertView.setTag(holder);
    }

    holder =(Holder) convertView.getTag();
    holder.tv_name.setText(***);
    holder.iv_avatar.set(***);
} 
</code></pre>

<p>以上就是BaseAdapter的典型用法，那么在项目里面的所有Adapter都存在Holder，并且都存在<code>holder.properties = (ViewType) findViewById(id)</code>的重复代码。可以想象一下，如果Holder中有比较多的属性，特别是如果一个AdapterView具有多个不同类型的layout，那么也需要多个不同Holder，getView将会特别复杂。<br />
<strong>geniousadapter</strong>对getView进行了一层封装，并将getView函数的两部分功能进行拆分，自动完成了生成ItemView和Holder的过程，通过一个抽象方法covert让子类实现数据绑定。子类需要实现两个抽象方法：</p>

<pre><code>  /**
  * 通过AdapterHolder填充view的属性,这个函数主要完成数据绑定的过程，使用方法：
  * holder.setText(R.id.tv_name,"张三").setText(R.id.tv_nickName,
  * "三儿").setImageResource(R.id.iv_avatar,R.drawable.ic_user_avatar);
  * holder 
  * item 当前item需要绑定的数据
  */
  protected abstract void convert(AdapterHolder holder, T item,int viewType);

 /**
  * layoutid至数据类型的映射,插入顺序对应itemviewtype
  * @return
  */
  protected abstract int[] assignLayoutIDs();
</code></pre>

<p><code>holder.setImageUrl(int,imageUrl)</code>可以通过使用者自己定义远程图片加载的方式。用户可以自己实现加载图片或者使用第三方图片加载缓存库，其接口如下：</p>

<pre><code>public interface ImageLoader {

public void load(ImageView imageView,String imageUrl);

//placeResId  默认图resid
public void load(ImageView imageView,String imageUrl,int placeResId);
}
</code></pre>

<p>比如我们可以使用picasso来完成加载图片的功能，在合适的位置来指定：</p>

<pre><code>DefaultAdapterConfig.setImageLoader(new ImageLoader() {
    @Override
    public void load(ImageView imageView, String imageUrl) {
        picasso.load(imageUrl).into(imageView);
    }

    @Override
    public void load(ImageView imageView, String imageUrl, int placeResId) {
        picasso.load(imageUrl).placeholder(placeResId).into(imageView);
    }
});
</code></pre>

<p>总结：genious Adapter可以使用户在getView方法中无需关注每一项ItemView生成的细节，而只需要处理数据绑定的逻辑即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的泛型方法]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa/"/>
    <updated>2014-12-04T16:36:56+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/04/javazhong-de-fan-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>在通过反射获取类的私有域时希望写一个方法，可以指定一个域的名字和域的类型，可以返回指定类型的对象。</p>

<!--more-->


<p>方法实现如下：</p>

<pre><code>/**
 * 获取一个类的私有域
 * @param fromClass 私有域所在的类
 * @param fieldName 域的名字
 * @param &lt;T&gt;
 * @return
 */
private &lt;T&gt; T getPrivateFiled(Class&lt;T&gt; fromClass, String fieldName) {
    T result = null;
    try {
        Field field = fromClass.getDeclaredField(fieldName);
        field.setAccessible(true);
        result = (T) field.get(this);
    } catch (NoSuchFieldException e) {
    } catch (IllegalAccessException e) {
    }
    return result;
}
</code></pre>

<p>泛型方法的结构如下：<br />
<img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_java%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95.png" alt="image" />
<br />
值得说明的是，声明泛型方法首先需要在返回值前面用<code>&lt;T&gt;</code>表明这是一个泛型方法，持有一个泛型。当然，一般来说我们需要在参数中传入一个class对象，不然函数的泛型没有任何意义了。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress写博客的个性配置]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/22/first/"/>
    <updated>2014-11-22T14:09:59+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/22/first</id>
    <content type="html"><![CDATA[<!--more-->


<h2>配置_config.yml</h2>

<ul>
<li>在首页只显示部分文章，而不是全文，可以通过<code>_config.yml</code>来设置，该文件中使用键值对来存储，<strong>键名: value</strong>中间的空格不能少。<code>excerpt_separator</code>，摘要标志，如果一篇文章中出现了这个标志，表明此文章在首页现实时需要采用摘要的模式，默认为<code>&lt;!--more--&gt;</code>。<code>excerpt_link</code>为读更多的link显示的文字，我们可以设置为&#8221;阅读全文&#8221;。</li>
</ul>


<h2>新建博客</h2>

<ul>
<li><p>设置使用指定的编辑器自动打开新建的blog。现在每次新建一篇blog，都要跑到<code>/source_posts</code>里面去打开，先到Rakefile文件里面的<code>## -- Misc Configs -- ##</code>注释下，在<code>server_port</code>下面新增一个键值对<code>editor = "open -a Mou"</code>。<br />
然后在文件中找到<code>new_post</code>任务，在最后一个<code>end</code>之前添加如下代码：</p>

<pre><code>  if #{editor}
      system "#{editor} #{filename}"
  end
</code></pre>

<p>如此一来，每次<code>rake new_post</code>都会自动打开Mou编辑器。</p></li>
<li><p>preview的时候自动打开浏览器预览。还是在<code>Rakefile</code>中，找到preview任务，加入代码</p>

<pre><code>  system "sleep 2; open http://localhost:#{server_port}/"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
