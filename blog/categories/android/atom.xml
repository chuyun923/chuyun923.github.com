<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 楚云之南]]></title>
  <link href="http://chuyun923.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2015-07-15T17:07:34+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 视图树状态保存]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun/"/>
    <updated>2015-07-13T18:13:40+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun</id>
    <content type="html"><![CDATA[<h1>Android 视图树状态保存</h1>

<h2>FragmentTabHost引起的思考</h2>

<p>公司的项目是一个标准的<code>FragmentTabHost</code>与<code>Fragment</code>构成的四TAB布局。其中三个TAB中都包含有<code>ListView</code>来展现一个列表。用户在切换TAB时，<code>ListView</code>的当前位置会自动被保存，切换回来之后会自动滚动到上次的位置。</p>

<p>我们知道<code>FragmentTabHost</code>内部对于<code>Fragment</code>的切换使用的是<code>attach</code>和dettach，此时必然会走Fragment的视图树的重建，也就是在切换tab的时候，fragment的UI元素会进行重建，当然也包括重建其中的ListView。那为什么在重建之后Listview能找到正确位置？为了找到解释，我开始查阅代码。</p>

<!--more-->


<p>第一个想法是否是我们通过<code>Fragment</code>的<code>onSaveInstanceState</code>和<code>Bundle</code>来保存的呢？但是看<code>Fragment</code>中的方法并没有任何代码进行保存，也没有进行恢复。</p>

<p>有人告诉我是通过<code>Adapter</code>来进行保存的，因为我们的<code>Fragment</code>会持有<code>listview</code>使用的<code>ListAdapter</code>，所以在重建的时候<code>listadapter</code>实际上复用之前的<code>adapter</code>，但是，通查adapter的代码，发现并没有任何保存当前位置的代码。</p>

<p>这样不科学的事情怎么会发生？一个新创建出来的ListView居然会保存之前一个ListView的状态？</p>

<h2>Android View状态保存</h2>

<p>我们经常有这样的经验，在一个<code>EditText</code>中我们输入一些文字，在屏幕翻转时，<code>EditText</code>进行重建，其中的文字还会保留(前提是你为这个<code>EditText</code>指定了ID)。
解释这个问题，我们需要从<code>Android</code>的<code>View</code>状态保存机制说起。</p>

<p>在<code>View</code>中<code>Android</code>定义了<code>saveHierarchyState</code>，它用来保存这个<code>View</code>所在的视图树的状态，传进来的参数是父<code>view</code>保存的状态，看到这里，你应该已经意识到了这又是<code>android View</code>中常用的递归伎俩。</p>

<pre><code>    public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) {
        dispatchSaveInstanceState(container);
     }

    protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
      //这里可以看到如果你不指定view的ID，系统是不会给你保存view的状态的
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        //获取当前View需要保存的Parcelable
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    "Derived class did not call super.onSaveInstanceState()");
        }
        if (state != null) {
            // Log.i("View", "Freezing #" + Integer.toHexString(mID)
            // + ": " + state);

            //妈蛋，直接是简单粗暴的 viewId ----&gt; Parcelable的映射
            container.put(mID, state);
        }
    }
}
</code></pre>

<p>从上面的代码，我们可以大致想象一下<code>saveHierarchySate</code>的过程，顶层的<code>view</code>调用<code>saveHierarchyState</code>,然后<code>dispatchSaveInstanceState</code>保存自己，为了让递归走下去，我们都能想象到在<code>ViewGroup</code>中的<code>dispatchSaveInstanceState</code>会调用子<code>View</code>的<code>saveHierachySate</code>，是不是这样呢，搂一眼<code>ViewGroup</code>中的代码：</p>

<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    //先把自己放到SparseArray中
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    //保存孩儿们的状态
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre>

<p>看到这里，相信你已经迫不及待想要看顶层<code>View</code>是在什么时机保存视图树信息的，Activity中的<code>onSaveInstanceState</code>有如下语句：</p>

<pre><code>outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
</code></pre>

<p>这里调用了跟到<code>PhoneWindow.saveHierarchyState()</code>,</p>

<pre><code>SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
mContentParent.saveHierarchyState(states);
</code></pre>

<p>这里交代地很清楚明白。ok，总结一下这个流程</p>

<p><code>Acitvity</code>在状态需要保存时，直接new了一个<code>SparseArray</code>，建立m<code>ovieId</code>和<code>Parcelable</code>的映射，其中每一个<code>View</code>都会使用一个<code>Parcelable</code>来序列化需要保存的内容，<code>ViewGroup</code>在保存了自己的同时，也会去调用子类的保存状态的方法，并把上面传下来的<code>SparseArray</code>一直往下传。</p>

<h2>视图树状态恢复</h2>

<p><strong>视图树保存下来的SparsesArray不是被ViewGroup自己持有(避免View被重新new出来，这些信息丢失，这也是前面疑惑的根源)。</strong>以<code>Activity</code>为例，我们可以看到整个视图树状态保存之后会放到一个<code>Bundle</code>中，那我们来看看视图树是如何恢复的。</p>

<p>在<code>Activity</code>的<code>onRestoreInstanceState</code>中</p>

<pre><code>    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
        }
    }
</code></pre>

<p>跟到<code>PhoneWindow</code>中的<code>restoreHierarchyState</code></p>

<pre><code>    SparseArray&lt;Parcelable&gt; savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
</code></pre>

<p>从Bundle中拿出之前保存的SparseArray，丢给顶层View的<code>restoreHierarchyState</code></p>

<pre><code>    public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) {
    dispatchRestoreInstanceState(container);
    }

    protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID) {
          //拿到当前View的id对应的Parcelable，注意，这个Parcelable很有可能是之前id相同的View保存的
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i("View", "Restoreing #" + Integer.toHexString(mID)
            // + ": " + state);
            mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(
                        "Derived class did not call super.onRestoreInstanceState()");
            }
        }
    }
    }
</code></pre>

<p>调用到View的<code>onRestoreInstanceState</code>，这里让子类去处理拿出的信息。</p>

<p>到这里，可以猜到在ViewGroup的<code>dispatchRestoreInstanceState</code>调用super方法(恢复自己)，同时应该会去恢复所有子View，这里不上代码了。</p>

<h2>回到Fragment状态保存的问题</h2>

<p>虽然<code>attach</code>和<code>dettach</code>并不会引起Activity的状态保存，但是由于视图树保存状态的机制可以知道，Fragment也可以只保留自己所持有的View，然后恢复Fragment的视图树。</p>

<p>在<code>FragmentManager</code>的<code>moveToState</code>方法中，调用了<code>saveFragmentViewState</code></p>

<pre><code>void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    //f.mView是Fragment的顶层View
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre>

<p> 往下走和Activity恢复视图树的过程一样鸟！</p>

<p> 这样看起来，ListView能够恢复到上次保存的位置，可以看到AbsListView中的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>进行了保存和恢复，其中保存一个变量 <code>mSyncPosition = ss.position;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Content Provider]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/16/android-provider/"/>
    <updated>2015-04-16T10:58:35+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/16/android-provider</id>
    <content type="html"><![CDATA[<p><code>ContentProvider</code>作为Android应用之间共享数据的桥梁，为共享数据提供了一个统一的访问方式(一套统一的接口)。</p>

<!--more-->


<h2>URI</h2>

<p>在Android中大量使用URI作为资源定位标识，它主要由 <code>scheme host(authority) path params组成</code>。例如我们有如下的一个<code>Content Provider</code>的URI如下：</p>

<pre><code>content://www.chuyun923.com/books/10086/title/firstWord
</code></pre>

<p>其中<code>content</code>，是Android为Content Provider规定的scheme；
PATH(<code>books/10086/title/firstWord</code>)可以直接表示用来操作的业务，表示书籍<code>_ID=10086</code>的书名的第一个单词。<strong>注意，我们可以在URI中定义各种奇葩的PATH来描述业务，但是的最终解释权归Content Provider的定义</strong></p>

<p>既然我们可以指定一些PATH表示业务，那么<code>Content Provider</code>必然需要去解析各种PATH，然后提供各种匹配的处理逻辑，此时，UriMatcher应运而生。</p>

<h3>UriMatcher</h3>

<p>对一个给定的Uri进行HOST和PATH的匹配，而Scheme不在考虑范围。对于PATH的匹配主要是挨个去比较各个PATH参数是否相等。</p>

<p>使用UriMatcher，首先需要给它配置一些配置URI，以及映射的<code>int</code>。</p>

<pre><code>    private static final UriMatcher uriMatcher;
    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("net.manoel.provider.Books", "books", 1);
        uriMatcher.addURI("net.manoel.provider.Books", "books/#/title", 2);
        uriMatcher.addURI("net.manoel.provider.Books","books/#/title/firstword",3);
    }
</code></pre>

<p>这里配置了三个业务PATH，第一个表示整个<code>books</code>整个表。第二URI表示指定Id的书名，第三个表示指定id的书名的首单词。</p>

<p>那么，
<code>books/12/title</code>将匹配第二个，在<code>Content Provider</code>收到这个<code>URI</code>时，可以使用<code>UriMatcher</code>得到2。
UriMatcher为URI提供了两种通配符 <code>#</code>代表数字；<code>*</code>代表任意字符。</p>

<p><strong>需要注意一点的是</strong>，<code>UriMatcher</code>进行匹配，会受到<code>addURI</code>的先后顺序影响。</p>

<p>如：<code>uriMatcher</code>按以下顺序添加：</p>

<pre><code>*/#
#/*
</code></pre>

<p>那么 <code>9/title</code>将不能获得匹配，是不是很奇怪？</p>

<pre><code>*/#/#
*/*/*
</code></pre>

<p> <code>books/10/title</code>也不能被匹配。</p>

<p>在匹配PATH是挨个参数进行，一旦一个路径参数被匹配，那么它就不会更换。
以<code>books/10/title</code>来说，匹配第一个patten的第一个参数 * 通过，10 匹配 <code>#</code>也通过，title不能匹配#，那么此时进行第二个patten的匹配。那么第二个patten必须满足<code>*/#</code>开头，否则就算是 <code>*/*</code>也不能通过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码(二)之JsonReader和JsonWriter]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li/"/>
    <updated>2015-01-10T14:17:21+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li</id>
    <content type="html"><![CDATA[<p>前文介绍了<code>Gson</code>对于<code>Json</code>规范中的类型进行了抽象定义，本文将来介绍<code>stream</code>包中的源码，这一块是<code>Gson</code>的核心代码之一。Gson中的JsonReader和JsonWriter抄自android.util包中的两个类，只是把其中的上下文栈由ArrayList换成了数组，提高了效率。这两个类为Json序列化和反序列化提供了基本接口。</p>

<!--more-->


<h1>反序列化&mdash;JsonReader</h1>

<h2>StringPool&ndash;(Flyweight Pattern)</h2>

<p>在Stream包中提供了一种针对String的优化处理，可以减少内存中String对象的个数，途径就是通过StringPool来对字符串进行复用。需要注意的是，在Java中字符串对象是不能被修改的，这也是这个Pool能正常工作的重要原因。StringPool原理和HashMap一模一样，通过一个2的n次方(512)作为数组的长度，字符串的hascode计算方式和String中的一致。为了使得hashcode分布分散一点，同样使用hashmap的补偿hash函数对hashcode进行处理，这一块的具体优化处理可以关注以后的HashMap源码分析。</p>

<h2>深度优先的解析策略</h2>

<p>Gson解析Json字符采用的是深度优先策略，下面是一个简单解析的栗子：</p>

<pre><code>[
&lt;!--数组中每一个对象为一个message对象--&gt;
{
  "id": 912345678901,
  "text": "How do I read a JSON stream in Java?",
  &lt;!--geo是一个double类型的数组--&gt;
  "geo": null,
  &lt;!--user对象--&gt;
  "user": {
    "name": "json_newb",
    "followers_count": 41
   }
},
{
  "id": 912345678902,
  "text": "@json_newb just use JsonReader!",
  "geo": [50.454722, -104.606667],
  "user": {
    "name": "jesse",
    "followers_count": 2
  }
}
]
</code></pre>

<p>深度解析的逻辑如下，先找到这个json字符串的开始位置，本例中是<code>[</code>，此时我们知道这个json字符串是一个数组，下一步从第一个元素开始解析(一层循环)。读取下一个字符，<code>{</code>,可以知道第一个元素为对象。对于<code>{</code>开始的JsonObject，我们知道它其中的内容肯定是键值对的样式，那我可以读取下一个字符，而且它必须为<code>"</code>(属性名)，然后去读取属性值。ok，我们可以看到这是一种非常正常的解析逻辑，其实Gson的解析就是这么做的。</p>

<h2>数据抽象</h2>

<p>为了进行上面的解析过程，Gson中定义了两种数据类型：</p>

<h3>JsonToken(解析类型)</h3>

<p>由于Json定义规范的原因，我们在解析过程中只要解析到一个结构的第一个元素再联系上下文就可以推断这个结构的类型。JsonToken用来描述<code>Json</code>中的<code>'{','}','[',']','"'</code>,<code>NULL</code>,<code>number</code>，<code>boolean</code>,属性名和属性字符串值，其实JsonToken的基本上等于每一个结构的开头，其中<code>"</code>既可以表示一个属性名也可以表示一个属性就是一个String，这需要按照上下文来确定。
在<code>JsonReader</code>定义了一个属性<code>token</code>，用来存储<code>Json</code>串解析位置的下一个<code>JsonToken</code>。</p>

<h3>JsonScope(解析上下文)</h3>

<p>用来描述当前正在解析的位置所处的一个状态，为解析提供一个上下文做推断。比如，目前我们解析到了一个<code>{</code>字符，那么下一个字符串必须是空或者&#8217;&ldquo;&lsquo;，如此我们可以推断这个<code>"</code>肯定是一个JsonToken.Name(属性名)。此外，JsonScope还可以描述一个JsonArray或者JsonObject目前解析到的位置是否是第一个元素。<code>JsonScope</code>被存放在一个栈中，而且是成对出现。</p>

<pre><code> private JsonScope[] stack = new JsonScope[32];
 {
   push(JsonScope.EMPTY_DOCUMENT);  //静态初始化时push空Json文件到栈顶
 }
 需要注意的是，这里这个栈之只实现了一个push操作，并提供了动态增长，出栈操作只需要简单的简单的stacksize--
</code></pre>

<h2>JsonReader工作流</h2>

<p><code>JsonReader</code>的构造函数接受一个<code>Reader</code>的参数，它是一个<code>Json</code>串的<code>InputStream</code>包装出来的<code>Reader</code>。</p>

<p>对于这个上文<code>Json</code>文档的解析，<code>JsonReader</code>的理逻辑如下：</p>

<pre><code>List&lt;Message&gt; result = new ArrayList&lt;Message&gt;(); 
jsonReader.beginArray();   //找到数组
while(jsonReader.hasnext) {
    Message message = new Message();
    jsonReader.beginObject();   //开始数组中的对象
    while(jsonReader.hasnext) {
        String name = jsonReader.nextName();
        if(name.equals("id")) {
            message.setId(jsonReader.nextString());
        }else if(name.equals("text")) {
            message.setText(jsonReader.nextString());
        }else if(name.equals("geo")&amp;&amp;jsonReader.peek()!=NULL) {
             List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();
             jsonReader.beginArray();
             while(jsonReader.hasnext()) {
                list.add(jsonReader.nextDouble());
             }
             JsonReader.endArray();
        }
        jsonReader.beginObject();
       .....开始解析User对象......
    }
    result.add(message);
}
</code></pre>

<h3>一些函数的解释</h3>

<h4>begin和 end系列函数</h4>

<p>其实这两个函数只是从业务的角度出发，封装了一下，实际两个函数都是调用<code>except(JsonToken)</code>，作用是寻找<code>json</code>字符串中的下一个<code>JsonToken</code>。以<code>beginObject()</code>函数来说，它直接调用<code>except(JsonToken.BEGIN_OBJECT)</code>。</p>

<pre><code>private void expect(JsonToken expected) throws IOException {
peek();         //找到下一个JsonToken，赋值给JsonReader的token属性
if (token != expected) {  //判断下一个Token是否等于指定的Token类型
  throw new IllegalStateException("Expected " + expected + " but was " +        peek() + " at line " + getLineNumber() + " column " +       getColumnNumber());
}
advance();  //下一步操作
}
</code></pre>

<h4>peek函数</h4>

<p>peek函数是JsonReader中最重要的函数，它的主要作用是进行上下文的判断，判断下一个JsonToken的读取方法。</p>

<p>下面看一下<code>peek()</code>函数的实现：</p>

<pre><code>public JsonToken peek() throws IOException {
//之前解析出来的token还没有被消费，直接取回
if (token != null) {
  return token;
}
//查看栈顶的JsonScope，这里可以看到JsonScope就是一个上下文的角色
switch (stack[stackSize - 1]) {
case EMPTY_DOCUMENT:    //json文档的开始 
  if (lenient) {    //json防止攻击引入的前导，防止跨域攻击
    consumeNonExecutePrefix();
  }
  stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;   //注意这里不是push而是直接替换栈顶元素
  JsonToken firstToken = nextValue();   //返回流中的下一个开始JsonToken，在上个例子中就是'['，也就是这里返回的是一个JsonToken.BEGIN_ARRAY,这个值还会被保存在token属性中
  if (!lenient &amp;&amp; token != JsonToken.BEGIN_ARRAY &amp;&amp; token != JsonToken.BEGIN_OBJECT) {   //一个json文档开始无非就是一个对象或者数组
    throw new IOException("Expected JSON document to start with '[' or '{' but was " + token
        + " at line " + getLineNumber() + " column " + getColumnNumber());
  }
  return firstToken;
case EMPTY_ARRAY:
    //目前处于一个数组中，但是还没有开始读取任何数据
  return nextInArray(true);
case NONEMPTY_ARRAY:
  return nextInArray(false);
case EMPTY_OBJECT: //目前处于一个JsonObject中但是还没有读取任何数据
  return nextInObject(true);
case DANGLING_NAME: //目前处于一个属性名的位置
  return objectValue();
case NONEMPTY_OBJECT:
  return nextInObject(false);
case NONEMPTY_DOCUMENT:
    //当前处于一个文档的解析上下文中，可以理解为根元素下一级的环境
  int c = nextNonWhitespace(false);
  if (c == -1) {
    return JsonToken.END_DOCUMENT;
  }
  pos--;
  if (!lenient) {
    throw syntaxError("Expected EOF");
  }
  //找下一个JsonToken
  return nextValue();
case CLOSED:
  throw new IllegalStateException("JsonReader is closed");
default:
  throw new AssertionError();
}
}
</code></pre>

<h4>nextIn**()</h4>

<p> 提供了数组、JsonObject的解析方法。</p>

<h4>nextValue()</h4>

<pre><code>找下一个JsonToken

private JsonToken nextValue() throws IOException {
int c = nextNonWhitespace(true);    //找到当前解析位置之后的第一个非空白字符
switch (c) {
case '{':
  push(JsonScope.EMPTY_OBJECT);   //进入一个JsonObject
  return token = JsonToken.BEGIN_OBJECT;

case '[':
  push(JsonScope.EMPTY_ARRAY);   //进入一个数组
  return token = JsonToken.BEGIN_ARRAY;
  //以上两种情况说明是一个新的结构的开始，所以需要pushJsonScope到栈中
case '\'':
  checkLenient(); // fall-through
case '"':
  //代表一个Json字符串值
  value = nextString((char) c);  //找到两个引号之间的String值
  return token = JsonToken.STRING;

default:
  pos--;
  return readLiteral();
}
}
</code></pre>

<h3>JsonReader总结</h3>

<p>JsonReader可以看作一个最基本的Json解析的接口，JsonReader中通过一个上下文来保存当前解析的环境，通过next**系列函数来获取下一个JsonToken。</p>

<h1>序列化&ndash;JsonWriter</h1>

<p>理解了JsonReader的源码之后，再来看Writer就相对来说简单多了。现在我们有一个数组，List<Message>，它的值就如上面的例子，那如何序列化呢?</p>

<pre><code>public void writeJsonStream(OutputStream out, List&lt;Message&gt; messages) throws IOException {
      JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
      writer.setIndent("\t");           //设置每一行的缩进
      writeMessagesArray(writer, messages);
      writer.close();
    }

    public void writeMessagesArray(JsonWriter writer, List&lt;Message&gt; messages) throws IOException {
      writer.beginArray();   //[
      for (Message message : messages) {
        writeMessage(writer, message);
      }
      writer.endArray();
    }

    public void writeMessage(JsonWriter writer, Message message) throws IOException {
      writer.beginObject(); //{
      writer.name("id").value(message.getId()); // "id":23435356
      writer.name("text").value(message.getText()); //"text":"dflsfldsfljd"
      if (message.getGeo() != null) {
        writer.name("geo");
        writeDoublesArray(writer, message.getGeo());
      } else {
        writer.name("geo").nullValue();
      }
      writer.name("user");
      writeUser(writer, message.getUser());
      writer.endObject();
    }

    public void writeUser(JsonWriter writer, User user) throws IOException {
      writer.beginObject();
      writer.name("name").value(user.getName());
      writer.name("followers_count").value(user.getFollowersCount());
      writer.endObject();
    }

    public void writeDoublesArray(JsonWriter writer, List&lt;Double&gt; doubles) throws IOException {
      writer.beginArray();
      for (Double value : doubles) {
        writer.value(value);
      }
      writer.endArray();
    }
</code></pre>

<h2>JsonWriter中的函数</h2>

<p>   事实上，可以看到JsonWriter的工作和JsonReader刚好相反，两个类的对json字符串的处理方式也基本相同。下面说一些业务流程中较为重要的方法。</p>

<h3>beginArray and beginObject</h3>

<p>开始向流中写入一个数组或者JsonObject的开始，注意，这里不仅仅是写入一个<code>[</code>或者一个<code>{</code>这么简单，首先会调用<code>writeDeferredName</code>方法，它的主要功能是如果这个开始的JsonElement是JsonObject中的一个属性，那么它的前面肯定有一个和上一个元素的分割符号和一个名字。</p>

<h3>endArray and endObject</h3>

<p>结束一个数组和对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码分析(一)之Json结构抽象和注解使用]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi/"/>
    <updated>2015-01-06T22:31:27+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<p>XML和Json作为最常用的两种网络传输格式而被广泛使用，XML在早期数据传输中作为首选，但是近年来Json以其轻量级和更容易编写和解析而越来越流行，Gson作为google的一个开源Json解析框架提供了稳定和快速解析的功能，可以读读它的源代码了解一番。</p>

<!--more-->


<p>说到Gson，其实它无非就是做两个工作，序列化(Object&mdash;>JsonString)和反序列化(JsonString&mdash;>Object)，后文所说的<em>两个方向</em>从Object到String和String到Object的两个方向。可想而知，对于序列化来说，是较为容易的工作，而对于反序列化即Json解析才是Gson的重头戏。既然是对Json字符串的解析，那么少不了对Json字符串中的结构进行抽象。</p>

<h2>Json抽象类</h2>

<h3>JsonElement</h3>

<p>这是Json中元素的基类，它只提供了若干个类型判断的接口，简单判断这个Json元素的类型。以下几个类型都是它的子类。</p>

<h4>1、JsonObject</h4>

<p>包含多个JsonElement的集合，它在Json中对应这种类型的数据：</p>

<pre><code>{
    "count":100,
    "users":[],
    "paging":{
        "offset":0,
        "limit":10,
        "hasMore":true
    }
}
</code></pre>

<p>这个data是一个典型的JsonObject，它以<code>{</code>开头，其中包含了一些类似数值，数组，对象等其他JsonElement的内容。<strong>其实每一个Json字符串的根节点都是一个JsonObject或者JsonArray。</strong></p>

<p>JsonObject提供了比较多的方法来得到Json中的信息，addProperty()函数可以在当前Json节点下新建子结点。</p>

<h4>2、JsonArray</h4>

<p>JsonArray也表示JsonElement的集合，注意：<strong>Json中的数组并不要求所有的数据类型都一样</strong>。</p>

<pre><code>    [true,"hello"] //JsonArray,包括一个boolean和一个hello类型。
</code></pre>

<p>需要讨论的是JsonArray和JsonObject的区别是什么？从集合的角度来说，JsonObject中的JsonElement是无序的，而JsonArray中的集合元素是有序的，从直观感受来说，你可以通过下标来引用JsonArray中的元素，而JsonObject是通过键值对的方式来访问的,<code>get("name")---&gt;value</code>。</p>

<h4>3、JsonPrimitive</h4>

<p>对应Json中的基本类型，比如boolean，int，当然提供了基本类型和包装类的自动替换。</p>

<pre><code>"count":100
</code></pre>

<h4>4、JsonNull</h4>

<p>空，对应null</p>

<pre><code>"person":null
</code></pre>

<p>以上就是Gson对应Json结构的封装。</p>

<h3>注解-Annotations</h3>

<h4>Expose</h4>

<p>在对象进行序列化和反序列化的过程中，我们可以通过注解来屏蔽某一些字段。这个注解默认有两个参数，<code>serialize</code>和<code>deserialize</code>都是默认true。如果设置为false，表示这个序列化(反)的过程中，这一个属性不需要进行处理。</p>

<p>通过Expose标注的属性在直接<code>new Gson()</code>的情况下不能生效，我们必须通过<code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>来创建一个可以识别Expose注解的Gson。</p>

<p>小小的吐槽一把，这个地方的使用确实不太方便，举个栗子，一般来说，我们进行序列化的时候都是希望某一个属性不会序列化到Json字符里面(反之亦然)，所以这里的一般思维是我要去处理这些特殊的属性。而如果你想通过Expose来去掉10个属性中的某一个，对不起，10个属性你都需要加上<code>@Expose</code>,然后对你想要处理的那个属性的Expose注解增加false参数，简直就是坑爹。。。。</p>

<pre><code>//我想让Person类在序列化时，不去序列化password，是不是很坑爹？
class Person {
    @Expose
    private String userName;
    @Expose (serialize = false)
    private String passWord;
}
</code></pre>

<p>此外，和java本身的序列化一样，如果一个属性设置为<code>transient</code>或者<code>static</code>,那么两个序列化的两个方向上都会屏蔽掉这个属性，虽然比Expose简单，但是不够灵活。</p>

<h4>SerializedName</h4>

<p>这个注解使用较多，它会改变两个方向上这个属性的名称，在序列化是，JsonElement的键值会被替换成这个名字；解析时，Json中键值为这个名字的JsonElement会赋值给被注解的属性。</p>

<pre><code>class Person {

@SerializedName(value = "A")
private int a ＝ 1;
private int b = 2;
}

//{"A":1,"b":2}  这个Json字符串和前面的Person等价
</code></pre>

<p>它使用场景最多的地方就是比如后端返回的json中的名称和我们定义的model类名称不一样时使用。</p>

<h4>Since 和 Until</h4>

<p>我们可以对我们的Model类进行序列化(两个方向)的版本控制，Since和Until刚好是两个相反的意义。</p>

<p>例子：</p>

<pre><code>class Person {
    @Since(value = 1.0)     //GsonBuilder指定版本要从1.0开始的Gson才能解析
    private int a = 1;

    @Until(value = 1.5)   //GsonBuilder指定版本到1.5的Gson都可以解析，超过了不能解析
    private int b = 2;
}
</code></pre>

<p>和Expose一样，要想Gson识别这两个注解，同样需要通过GsonBuilder.setVersion(double).create()来实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ActionBar]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/23/android-actionbar/"/>
    <updated>2014-12-23T10:58:00+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/23/android-actionbar</id>
    <content type="html"><![CDATA[<p>ActionBar作为Android3.0系统引入的一个重要的android app的风格，了解它的使用方法是每一个android开发者都必须要掌握的，本文主要基于android官方文档，对一些不常用的内容进行了删减，整理而成。</p>

<!--more-->


<p>说起3.0以后的ActionBar，其实在做3.0以前开发的童鞋应该有印象，Android提供了一个TitleBar，只不过默认的TitleBar只能显示一个标题和一个图标。它的样子大概如下：<br />
<img src="http://androidpeople.files.wordpress.com/2009/12/withicon.jpg" alt="" /></p>

<p>如果需要自己定义一个更加炫酷的Titlebar,比较麻烦，可以参考这篇文章：<a href="http://www.cnblogs.com/a284628487/archive/2013/06/07/3125265.html"><strong>自定义TitleBar</strong></a></p>

<p>ActionBar是TitleBar的增强版本，主要包括四个部分：</p>

<ol>
<li>为app提供一个唯一图片标识和导航的button,如果当前页面不是应用的首页，应该在app icon的左边添加返回的剪头。</li>
<li>切换界面上显示的view，官方名称叫view control。</li>
<li>放置一些显式的按钮，长按会显示它的title</li>
<li>放置一个action overflow</li>
</ol>


<p>对应如下图片：</p>

<p><img src="https://developer.android.com/design/media/action_bar_basics.png" alt="" /></p>

<p>正常的ActionBar会占据一定的屏幕空间，在ActionBar显示或者隐藏时，屏幕中的数据都会重绘去适应。如果我们需要ActionBar浮动在内容上面，可以将<code>windowActionBarOverlay</code>属性设置为true。</p>

<h2>增加ActionBar的Item</h2>

<p>在android菜单中曾经提到如何在ActionBar中增加菜单项，这里不再赘述。这里补充一个小的case：</p>

<p> 在ActionBar上显示的item也可以同时显示icon和title，当然前提是ActionBar的空间富余。通过在showAsAction中增加withText。</p>

<h2>分离的ActionBar(split)</h2>

<p>在分辨率不大的设备上，如果有足够多的Item需要显示，可能面临着屏幕宽度不够而显示不了那么多的Icon。分离ActionBar中的logo和菜单项，将菜单项移动到屏幕的下面，如图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-splitaction@2x.png" alt="" /></p>

<p>如果需要系统处理，那么我们需要指定属性：<code>uiOptions="splitActionBarWhenNarrow"</code>，但是如果需要支持低版本，我们可以这样写：</p>

<pre><code>    &lt;manifest ...&gt;
        &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
            &lt;meta-data android:name="android.support.UI_OPTIONS"
               android:value="splitActionBarWhenNarrow" /&gt;
        &lt;/activity&gt;
    &lt;/manifest&gt;
</code></pre>

<h2>ActionBar的导航button</h2>

<p>如果设置ActionBar.setDisplayHomeAsUpEnable(true),会产生一个导航按钮，如图所示：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-up.png" alt="" /></p>

<p>这个按钮和系统的back按键的区别在于，系统的back键有时候仅仅是为了返回到屏幕的上一次状态，而点击这个导航键就会返回到上一次的界面。
如果仅仅set这个导航键可见，它并不会响应任何操作，我们需要手动去指定点击这个导航键将会打开那个Activity，有两种方法可以来指定：</p>

<ol>
<li>在Menifest文件中通过activity的parentActivityname属性指定，当然这个属性是4.1加入的，如果要兼容之前的版本，可以通过meta的方式来做到。</li>
<li>在Activity中复写getParentActivityIntent，可以指定在app内导航的Intent。在别的应用中打开app，可以通过复写onCreateNavigateUpTaskStack来实现。</li>
</ol>


<p>注意，在support v7包中的actionbarActivity中，对以上提供了默认实现。</p>

<h2>ActionView</h2>

<p>actionview是在点击action button之后，一个显示出来的交互view,如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-searchview@2x.png" alt="" /></p>

<p>可以通过Menu item的<code>actionViewClass</code>来指定一个widget。我们也可以直接自己指定一个自定义布局给Action button，只需要把layout的id赋值给<code>actionLayout</code>即可。</p>

<p>app要获取这个Action View中的一些事件，可以在onCreateOptionsMenu中通过<code>menuItem.getActionView()</code>来获得。</p>

<p>下面来说一个比较有意思的可折叠的actionview，前文可知，如果设置actionLayout，那么如果ActionBar上面空间足够时，会直接把这个自定义的layout显示出来，但是如果这个item被放到overflow里面去了呢？此时<code>showAction</code>中的一个属性<code>collapseActionView</code>的作用就会显示出来，这个属性的作用是：</p>

<p>如果这个action button被放到overflow中，点击后还是可以把它的actionview打开(可折叠)，如果不加这个属性，那么系统将不会打开actionview。如果是打开折叠的actionview，ActionBar会自动把导航剪头加上，并且清空ActionBar上面的action button(除去overflow按钮)，如下图：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_5B4AFB05-1AFC-4F4F-887F-304187E96E16.png" alt="" /></p>

<p>我们可以在<code>onCreateOptionsMenu</code>中  通过<code>MenuItemCompat.setOnActionExpandListener</code>来监听actionview的扩张事件。</p>

<h2>Action Provider</h2>

<p>上一节提到的actionview，它是直接在ActionBar上面展示出来，ActionProvider是在ActionBar上展示一个下拉的菜单，如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-shareaction@2x.png" alt="" /></p>

<p>创建一个Action provider可以通过指定给<code>android:actionProviderClass</code>属性一个ActionProvider即可。</p>

<h2>添加导航的tab</h2>

<p>这种方式已经不被推荐使用了，所以这里不做详细解释，使用它很简单。</p>

<h2>下拉导航</h2>

<p>下拉导航是在ActionBar的左边提供一个action provider类似的下拉框，可以使用在改变界面内容的频率不频繁的情况下可以使用Drop-down Navigation来进行切换选项的提供，如下图：</p>

<p><img src="http://developer.android.com/images/ui/actionbar-dropdown@2x.png" alt="" /></p>

<p>使用下拉导航有几个步骤：</p>

<ol>
<li>创建一个SpinnerAdapter，提供下拉项的布局</li>
<li>实现一个选择接口 <code>ActionBar.OnNavigationListener</code>，处理事件</li>
<li>在Activity的onCreate里面调用setnavigationMode()</li>
<li>actionbar.setListNavigationCallbacks(spinneradapter,mnavigationcallback),将1和2定义的东西传进去</li>
</ol>

]]></content>
  </entry>
  
</feed>
