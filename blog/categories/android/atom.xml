<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 楚云之南]]></title>
  <link href="http://chuyun923.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2015-07-31T16:11:34+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[View事件传递之父View和子View之间的那点事]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/28/viewshi-jian-zhi-fu-viewhe-zi-viewzhi-jian-de-na-dian-shi/"/>
    <updated>2015-07-28T09:29:14+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/28/viewshi-jian-zhi-fu-viewhe-zi-viewzhi-jian-de-na-dian-shi</id>
    <content type="html"><![CDATA[<h1>View事件传递之父View和子View之间的那点事</h1>

<p><code>Android</code>事件传递流程在网上可以找到很多资料，<code>FrameWork</code>层输入事件和消费事件，可以参考：</p>

<ol>
<li><a href="http://blog.csdn.net/stonecao/article/details/6759189">Touch事件派发过程详解</a></li>
</ol>


<p>这篇blog阐述了底层是如何处理屏幕输，并往上传递的。<code>Touch</code>事件传递到<code>Activity</code>的<code>DecorView</code>时，往下走就是<code>ViewGroup</code>和子<code>View</code>之间的事件传递，可以参考郭神的这两篇博客</p>

<ol>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9097463">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/9153747">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a></li>
</ol>


<p>郭神的两篇博客清楚明白地说明了<code>View</code>之间事件传递的大方向，但是具体的一些晦暗的细节阐述较少，本文主要是总结这两篇博客的同时，侧重于两点：</p>

<ol>
<li>事件分发过程中一些细节到底如何实现的？</li>
<li>子<code>view</code>到底如何和父<code>View</code>抢事件，父<code>View</code>又是如何拦截事件不发送给子<code>View</code>，以及如果我们需要处理这种混乱的关系才能让两者和谐相处？。</li>
</ol>


<!--more-->


<h2>MotionEvent抽象</h2>

<p>要明白<code>View</code>的事件传递，很有必要先说一下<code>Touch</code>事件是如何在<code>Android</code>系统中抽象的，这主要使用的就是<code>MotionEvent</code>。这个类经历了几次重大的修改，一次是在2.x版本支持多点触摸，一次是4.x将大部分代码甩给<code>native</code>层处理。</p>

<h3>一次简单的事件</h3>

<p>我们先举个栗子来说明一次完整的事件，用户触屏 滑动 到手机离开屏幕，这认为是一次完整动作序列(<code>movement traces</code>)。一个动作序列中包含很多动作<code>Action</code>，比如在用户按下时，会封装一个<code>MotionEvent</code>，分发给视图树，我们可以通过<code>motionevent.getAction</code>拿到这个动作是<code>ACTION_DOWN</code>。同样，在手指抬起时，我们可以接收到<code>Action</code>类型是<code>Action_UP</code>的<code>MotionEvent</code>。对于滑动(<code>MOVE</code>)这个操作，<code>Android</code>为了从效率出发，会将多个<code>MOVE</code>动作打包到一个<code>MotionEvent</code>中。通过<code>getX getY</code>可以获取当前的坐标，如果要访问打包的缓存数据，可以通过<code>getHistorical**()</code>函数来获取。</p>

<h3>加入多点触摸</h3>

<p>对于单点的操作来看，<code>MotionEvent</code>显得比较简单，但是考虑引入多点触摸呢？我们定义一个接触点为(<code>Pointer</code>)。我们从<code>onTouch</code>接受到一个<code>MotionEvent</code>，怎么拿到多个触碰点的信息？为了解开笔者刚开始学习这部分知识时的困惑，我们首先树立起一种概念：一个<code>MotionEvent</code>只允许有一个<code>Action</code>(动作)，而且这个<code>Action</code>会包含触发这次<code>Action</code>的触碰点信息，对于<code>MOVE</code>操作来说，一定是当前所有触碰点都在动。只有<code>ACTION_POINTER_DOWN</code>这类事件事件会在<code>Action</code>里面指定是哪一个<code>POINTER</code>按下。</p>

<p>在<code>MotionEvent</code>的底层实现中，是通过一个16位来存储<code>Action</code>和<code>Pointer</code>信息(<code>PointerIndex</code>)。低8位表示<code>Action</code>，理论上可以表示255种动作类型;高8位表示触发这个<code>Action</code>的<code>PointerIndex</code>，理论上<code>Android</code>最多可以支持255点同时触摸，但是在上层代码使用的时候，默认多点最多存在32个，不然事件在分发的时候会有问题。</p>

<p><code>MotionEvent</code>中多个手指的操作<code>API</code>大部分都是通过<code>pointerindex</code>来进行的，如：获取不同<code>Pointer</code>的触碰位置,<code>getX(int pointerIndex)</code>;获取<code>PointerId</code>等等。大部分情况下，<code>pointerid == pointeridex</code>。</p>

<p><code>ACTION_DOWN</code> OR <code>ACTION_POINTER_DOWN</code>:</p>

<p>这两个按下操作的区别是<code>ACTION_DOWN</code>是一个系列动作的开始，而<code>ACTION_POINTER_DOWN</code>是在一个系列动作中间有另外一个触碰点触碰到屏幕。</p>

<p>这部分详细的描述，请参考：
<a href="http://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent</a></p>

<p>到这里，铺垫终于结束了，我们开始直奔主题。</p>

<h2>View的事件传递</h2>

<p><code>Android</code>的<code>Touch</code>事件传递到<code>Activity</code>顶层的<code>DecorView</code>(一个<code>FrameLayout</code>)之后，会通过<code>ViewGroup</code>一层层往视图树的上面传递，最终将事件传递给实际接收的<code>View</code>。下面给出一些重要的方法。如果你对这个流程比较熟悉的话，可以跳过这里，直接进入第二部分。</p>

<h3>dispatchTouchEvent</h3>

<p>事件传递到一个<code>ViewGroup</code>上面时，会调用<code>dispatchTouchEvent</code>。代码有删减</p>

<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {

    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

        // Attention 1 ：在按下时候清除一些状态
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            //注意这个方法
            resetTouchState();
        }

        // Attention 2：检查是否需要拦截
        final boolean intercepted;
        //如果刚刚按下 或者 已经有子View来处理
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }
        } else {
            //  不是一个动作序列的开始 同时也没有子View来处理，直接拦截
            intercepted = true;
        }

          //事件没有取消 同时没有被当前ViewGroup拦截，去找是否有子View接盘
        if (!canceled &amp;&amp; !intercepted) {
                //如果这是一系列动作的开始  或者有一个新的Pointer按下 我们需要去找能够处理这个Pointer的子View
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                final int actionIndex = ev.getActionIndex(); // always 0 for down

                //上面说的触碰点32的限制就是这里导致
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);

                    //对当前ViewGroup的所有子View进行排序，在上层的放在开始
                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null
                            &amp;&amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = customOrder
                                ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null)
                                ? children[childIndex] : preorderedList.get(childIndex);

                              // canViewReceivePointerEvents visible的View都可以接受事件
                              // isTransformedTouchPointInView 计算是否落在点击区域上
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                              //能够处理这个Pointer的View是否已经处理之前的Pointer，那么把
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }                           }
                        //Attention 3 : 直接发给子View
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                    }
                }

            }
        }

        // 前面已经找到了接收事件的子View，如果为NULL，表示没有子View来接手，当前ViewGroup需要来处理
        if (mFirstTouchTarget == null) {
            // ViewGroup处理
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {

            if(alreadyDispatchedToNewTouchTarget) {
                                //ignore some code
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                }
            }

        }
    return handled;
}
</code></pre>

<p>上面代码中的<strong><em><code>Attention</code></em></strong>在后面部分将会涉及，重点注意。</p>

<p>这里需要指出一点的是，一系列动作中的不同<code>Pointer</code>可以分配给不同的<code>View</code>去响应。ViewGroup会维护一个<code>PointerId</code>和处理<code>View</code>的列表<code>TouchTarget</code>，一个<code>TouchTarget</code>代表一个可以处理<code>Pointer</code>的子<code>View</code>，当然一个<code>View</code>可以处理多个<code>Pointer</code>，比如两根手指都在某一个子<code>View</code>区域。<code>TouchTarget</code>内部使用一个<code>int</code>来存储它能处理的<code>PointerId</code>，一个<code>int</code>32位，这也就是上层为啥最多只能允许同时最多32点触碰。</p>

<p>看一下<code>Attention 3</code> 处的代码，我们经常说<code>view</code>的<code>dispatchTouchEvent</code>如果返回false，那么它就不能系列动作后面的动作，这是为啥呢？因为<code>Attention 3</code>处如果返回<code>false</code>，那么它不会被记录到<code>TouchTarget</code>中，ViewGroup认为你没有能力处理这个事件。</p>

<p>这里可以看到，<code>ViewGroup</code>真正处理事件是在<code>dispatchTransformedTouchEvent</code>里面，跟进去看看：</p>

<h3>dispatchTransformedTouchEvent</h3>

<pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {

      //没有子类处理，那么交给viewgroup处理
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }
    return handled;
}
</code></pre>

<p>可以看到这里不管怎么样，都会调用<code>View</code>的<code>dispatchTouchEvent</code>,这是真正处理这一次点击事件的地方。</p>

<h3>dispatchTouchEvent</h3>

<pre><code>    public boolean dispatchTouchEvent(MotionEvent event) {
        if (onFilterTouchEventForSecurity(event)) {
        //先走View的onTouch事件，如果onTouch返回True
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }
      return result;
    }
</code></pre>

<p>我们给<code>View</code>设置的<code>onTouch</code>事件处在一个较高的优先级，如果<code>onTouch</code>执行返回<code>true</code>，那么就不会去走<code>view</code>的<code>onTouchEvent</code>，而我们一些点击事件都是在<code>onTouchEvent</code>中处理的，这也是为什么<code>onTouch</code>中返回true，<code>view</code>的点击相关事件不会被处理。</p>

<h3>小小总结一下这个流程</h3>

<p><code>ViewGroup</code>在接受到上级传下来的事件时，如果是一系列<code>Touch</code>事件的开始(<code>ACTION_DOWN</code>)，<code>ViewGroup</code>会先看看自己需不需要拦截这个事件(<code>onInterceptTouchEvent</code>，<code>ViewGroup</code>的默认实现直接返回<code>false</code>表示不拦截)，接着<code>ViewGroup</code>遍历自己所有的<code>View</code>。找到当前点击的那个<code>View</code>，马上调用目标<code>View</code>的<code>dispatchTouchEvent</code>。如果目标<code>View</code>的<code>dispatchTouchEvent</code>返回false，那么认为目标<code>View</code>只是在那个位置而已，它并不想接受这个事件，只想安安静静的做一个<code>View</code>(我静静地看着你们装*)。此时，<code>ViewGroup</code>还会去走一下自己<code>dispatchTouchEvent，Done！</code></p>

<h2>子View和父View的撕*大战</h2>

<p>终于来到本文的重要环节，子View和父布局(<code>ViewGroup</code>)是如何撕逼的。我们经常遇到这样的问题：在<code>ListView</code>中放一个<code>ViewPager</code>不能滑动的问题，其实这里就会涉及到子View和布局之间的协商，事件处理到底你上还是我上。</p>

<p>首先需要明确一点的是，一个事件肯定是由<code>ViewGroup</code>传递给自己的子<code>View</code>的，所以<code>ViewGroup</code>具有绝对的权威来禁止事件往下传，这就是<code>onInterceptTouchEvent</code>方法。可以看上面<code>ViewGroup中的dispatchTouchEvent</code>的<code>Attention 1</code>和<code>Attention 2</code>。</p>

<p>先看<code>Attetion2</code>：
进行判断有有两个条件：1，如果是一次新的事件 or  在一次事件中但是已经有子View来处理这个事件，那么父类需要去看看是否拦截这次事件。否则，直接拦截(此时处于一系列动作的中间，而且没有子view来接盘，那么ViewGroup就直接拦下来)。</p>

<p>决定是否拦截有两个步骤，</p>

<ol>
<li><code>disallowIntercept</code> 是否驳回拦截，默认<code>false</code>。注意这个值是子<code>View</code>和撕*的关键，因为<code>ViewGroup</code>开放了给这个标记赋值的接口<code>requestDisallowInterceptTouchEvent()</code>，而且这个方法直接往上递归，这个<code>ViewGroup</code>的各级父容器都会设置驳回拦截。</li>
<li><code>onInterceptTouchEvent</code> 虽然<code>ViewGroup</code>中默认返回false，但是在很多有滑动功能的<code>ViewGroup</code>里面(如<code>scrollview ListView</code>等)会处理各种情况，决定是否拦截这个事件，所以就会出现之前说的<code>ListView</code>中的<code>Viewpager</code>不能滑动的问题，原因是事件被父View拦截了。</li>
</ol>


<p>在<code>Attetion1</code>的位置如果是一次新的<code>ACTION_DOWN</code>，那么会把之前事件传递设置的各种状态清除。</p>

<h3>对ViewGroup来说需要做什么</h3>

<p>对于一个需要拦截事件的<code>ViewGroup</code>，它通常都有一些特殊的操作，比如<code>ScrollView</code>，比如<code>ViewPager</code>，它重写<code>onInterceptTouchEvent</code>是非常关键的，这也是能和子<code>View</code>和谐相处的关键。举个例子，我自己定义了一个<code>ViewGroup</code>：</p>

<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if(ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
        return true;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre>

<p>这样会发生什么？</p>

<p>所有位于MyViewGroup中的子View收不到任何的事件，原因可以看一下<code>Attention2</code>的代码，判断是否拦截是在系列动作按下时会进行判断，如果此时拦截，那么直接不会去查找相应处理的子View，所以<code>touchtarget</code>为空，那么接下来的动作都直接被<code>ViewGroup</code>笑纳。</p>

<p>所以哪怕再强势的<code>ViewGroup</code>，一般都是在<code>Down</code>的时候给子类机会去掉用<code>requestDisallowInterceptTouchEvent</code>，如设置驳回拦截，那么在ViewGroup分发事件的时候，会跳过<code>onInterceptTouchEvent</code>的执行。</p>

<h3>子View需要做什么</h3>

<p>对于子View来说，在合适的时机调用<code>requestDisallowInterceptTouchEvent</code>即可。当然啥时候合适？对于一个<code>View</code>来说，那就是在<code>dispatchTouchEvent</code>或者<code>onTouchEvent</code>来调用。</p>

<p>对于<code>ViewGroup</code>来说，通常我们会在<code>onInterceptTouchEvent</code>进行判断。比如我们经常会遇到在<code>ListView</code>里面套了<code>ViewPager</code>导致<code>ViewPager</code>不能滑动的问题，通常的处理方式：</p>

<pre><code> @Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    if (absListView != null) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDownX = event.getX();
                mDownY = event.getY();
                    //ACTION_DOWN的时候，赶紧把事件hold住
                getParent().requestDisallowInterceptTouchEvent(true);
                break;
            case MotionEvent.ACTION_MOVE:

                if(Math.abs(event.getX() - mDownX)&gt;Math.abs(event.getY()-mDownY)) {
                    getParent().requestDisallowInterceptTouchEvent(true);
                }else {
                    //发现不是自己处理，还给父类
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                    //其实这里是多余的
                getParent().requestDisallowInterceptTouchEvent(false);
        }

    }
    return super.onInterceptTouchEvent(event);
}
</code></pre>

<h2>总结</h2>

<p>本来打算写一个短篇的，结果一个不小心，弄成了长篇大论。</p>

<p>最后需要注意一点的是，所有我们上述讨论的内容都是在一层层递归中进行,而且<code>requestDisallowInterceptTouchEvent</code>这个函数也是递归调用的。</p>

<p>我们可以认为<code>ViewGroup</code>是一个具有绝对话语权但是从不专政的霸道总裁，它自己可以拦截处理某些事件，比如<code>Viewpager</code>的横滑，但是它也可以给子View足够的空间去要求这个事件给自己处理。作为一名开发者，一方面在自己定义<code>ViewGroup</code>时需要考虑能够给子View足够空间中断自己的拦截；一方面自己定义View时，我们需要在合适的时候跟父View索要事件。<code>ViewPager(新版)</code>作为容器来说，它需要拦截横滑事件，同时，自己具备了和父<code>View</code>争抢事件的能力，所以不管把<code>ViewPager</code>放到什么布局中，它都能正确处理。看看它的<code>onInterceptTouchEvent</code>怎么写的吧，完美的体现了这一思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 视图树状态保存]]></title>
    <link href="http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun/"/>
    <updated>2015-07-13T18:13:40+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/07/13/android-viezhuang-tai-bao-cun</id>
    <content type="html"><![CDATA[<h1>Android 视图树状态保存</h1>

<h2>FragmentTabHost引起的思考</h2>

<p>公司的项目是一个标准的<code>FragmentTabHost</code>与<code>Fragment</code>构成的四TAB布局。其中三个TAB中都包含有<code>ListView</code>来展现一个列表。用户在切换TAB时，<code>ListView</code>的当前位置会自动被保存，切换回来之后会自动滚动到上次的位置。</p>

<p>我们知道<code>FragmentTabHost</code>内部对于<code>Fragment</code>的切换使用的是<code>attach</code>和dettach，此时必然会走Fragment的视图树的重建，也就是在切换tab的时候，fragment的UI元素会进行重建，当然也包括重建其中的ListView。那为什么在重建之后Listview能找到正确位置？为了找到解释，我开始查阅代码。</p>

<!--more-->


<p>第一个想法是否是我们通过<code>Fragment</code>的<code>onSaveInstanceState</code>和<code>Bundle</code>来保存的呢？但是看<code>Fragment</code>中的方法并没有任何代码进行保存，也没有进行恢复。</p>

<p>有人告诉我是通过<code>Adapter</code>来进行保存的，因为我们的<code>Fragment</code>会持有<code>listview</code>使用的<code>ListAdapter</code>，所以在重建的时候<code>listadapter</code>实际上复用之前的<code>adapter</code>，但是，通查adapter的代码，发现并没有任何保存当前位置的代码。</p>

<p>这样不科学的事情怎么会发生？一个新创建出来的ListView居然会保存之前一个ListView的状态？</p>

<h2>Android View状态保存</h2>

<p>我们经常有这样的经验，在一个<code>EditText</code>中我们输入一些文字，在屏幕翻转时，<code>EditText</code>进行重建，其中的文字还会保留(前提是你为这个<code>EditText</code>指定了ID)。
解释这个问题，我们需要从<code>Android</code>的<code>View</code>状态保存机制说起。</p>

<p>在<code>View</code>中<code>Android</code>定义了<code>saveHierarchyState</code>，它用来保存这个<code>View</code>所在的视图树的状态，传进来的参数是父<code>view</code>保存的状态，看到这里，你应该已经意识到了这又是<code>android View</code>中常用的递归伎俩。</p>

<pre><code>    public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) {
        dispatchSaveInstanceState(container);
     }

    protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
      //这里可以看到如果你不指定view的ID，系统是不会给你保存view的状态的
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        //获取当前View需要保存的Parcelable
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    "Derived class did not call super.onSaveInstanceState()");
        }
        if (state != null) {
            // Log.i("View", "Freezing #" + Integer.toHexString(mID)
            // + ": " + state);

            //妈蛋，直接是简单粗暴的 viewId ----&gt; Parcelable的映射
            container.put(mID, state);
        }
    }
}
</code></pre>

<p>从上面的代码，我们可以大致想象一下<code>saveHierarchySate</code>的过程，顶层的<code>view</code>调用<code>saveHierarchyState</code>,然后<code>dispatchSaveInstanceState</code>保存自己，为了让递归走下去，我们都能想象到在<code>ViewGroup</code>中的<code>dispatchSaveInstanceState</code>会调用子<code>View</code>的<code>saveHierachySate</code>，是不是这样呢，搂一眼<code>ViewGroup</code>中的代码：</p>

<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    //先把自己放到SparseArray中
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    //保存孩儿们的状态
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre>

<p>看到这里，相信你已经迫不及待想要看顶层<code>View</code>是在什么时机保存视图树信息的，Activity中的<code>onSaveInstanceState</code>有如下语句：</p>

<pre><code>outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
</code></pre>

<p>这里调用了跟到<code>PhoneWindow.saveHierarchyState()</code>,</p>

<pre><code>SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
mContentParent.saveHierarchyState(states);
</code></pre>

<p>这里交代地很清楚明白。ok，总结一下这个流程</p>

<p><code>Acitvity</code>在状态需要保存时，直接new了一个<code>SparseArray</code>，建立m<code>ovieId</code>和<code>Parcelable</code>的映射，其中每一个<code>View</code>都会使用一个<code>Parcelable</code>来序列化需要保存的内容，<code>ViewGroup</code>在保存了自己的同时，也会去调用子类的保存状态的方法，并把上面传下来的<code>SparseArray</code>一直往下传。</p>

<h2>视图树状态恢复</h2>

<p><strong>视图树保存下来的SparsesArray不是被ViewGroup自己持有(避免View被重新new出来，这些信息丢失，这也是前面疑惑的根源)。</strong>以<code>Activity</code>为例，我们可以看到整个视图树状态保存之后会放到一个<code>Bundle</code>中，那我们来看看视图树是如何恢复的。</p>

<p>在<code>Activity</code>的<code>onRestoreInstanceState</code>中</p>

<pre><code>    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        if (mWindow != null) {
        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
        if (windowState != null) {
            mWindow.restoreHierarchyState(windowState);
        }
        }
    }
</code></pre>

<p>跟到<code>PhoneWindow</code>中的<code>restoreHierarchyState</code></p>

<pre><code>    SparseArray&lt;Parcelable&gt; savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
</code></pre>

<p>从Bundle中拿出之前保存的SparseArray，丢给顶层View的<code>restoreHierarchyState</code></p>

<pre><code>    public void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container) {
    dispatchRestoreInstanceState(container);
    }

    protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID) {
          //拿到当前View的id对应的Parcelable，注意，这个Parcelable很有可能是之前id相同的View保存的
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i("View", "Restoreing #" + Integer.toHexString(mID)
            // + ": " + state);
            mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(
                        "Derived class did not call super.onRestoreInstanceState()");
            }
        }
    }
    }
</code></pre>

<p>调用到View的<code>onRestoreInstanceState</code>，这里让子类去处理拿出的信息。</p>

<p>到这里，可以猜到在ViewGroup的<code>dispatchRestoreInstanceState</code>调用super方法(恢复自己)，同时应该会去恢复所有子View，这里不上代码了。</p>

<h2>回到Fragment状态保存的问题</h2>

<p>虽然<code>attach</code>和<code>dettach</code>并不会引起Activity的状态保存，但是由于视图树保存状态的机制可以知道，Fragment也可以只保留自己所持有的View，然后恢复Fragment的视图树。</p>

<p>在<code>FragmentManager</code>的<code>moveToState</code>方法中，调用了<code>saveFragmentViewState</code></p>

<pre><code>void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    //f.mView是Fragment的顶层View
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre>

<p> 往下走和Activity恢复视图树的过程一样鸟！</p>

<p> 这样看起来，ListView能够恢复到上次保存的位置，可以看到AbsListView中的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>进行了保存和恢复，其中保存一个变量 <code>mSyncPosition = ss.position;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Content Provider]]></title>
    <link href="http://chuyun923.github.io/blog/2015/04/16/android-provider/"/>
    <updated>2015-04-16T10:58:35+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/04/16/android-provider</id>
    <content type="html"><![CDATA[<p><code>ContentProvider</code>作为Android应用之间共享数据的桥梁，为共享数据提供了一个统一的访问方式(一套统一的接口)。</p>

<!--more-->


<h2>URI</h2>

<p>在Android中大量使用URI作为资源定位标识，它主要由 <code>scheme host(authority) path params组成</code>。例如我们有如下的一个<code>Content Provider</code>的URI如下：</p>

<pre><code>content://www.chuyun923.com/books/10086/title/firstWord
</code></pre>

<p>其中<code>content</code>，是Android为Content Provider规定的scheme；
PATH(<code>books/10086/title/firstWord</code>)可以直接表示用来操作的业务，表示书籍<code>_ID=10086</code>的书名的第一个单词。<strong>注意，我们可以在URI中定义各种奇葩的PATH来描述业务，但是的最终解释权归Content Provider的定义</strong></p>

<p>既然我们可以指定一些PATH表示业务，那么<code>Content Provider</code>必然需要去解析各种PATH，然后提供各种匹配的处理逻辑，此时，UriMatcher应运而生。</p>

<h3>UriMatcher</h3>

<p>对一个给定的Uri进行HOST和PATH的匹配，而Scheme不在考虑范围。对于PATH的匹配主要是挨个去比较各个PATH参数是否相等。</p>

<p>使用UriMatcher，首先需要给它配置一些配置URI，以及映射的<code>int</code>。</p>

<pre><code>    private static final UriMatcher uriMatcher;
    static{
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI("net.manoel.provider.Books", "books", 1);
        uriMatcher.addURI("net.manoel.provider.Books", "books/#/title", 2);
        uriMatcher.addURI("net.manoel.provider.Books","books/#/title/firstword",3);
    }
</code></pre>

<p>这里配置了三个业务PATH，第一个表示整个<code>books</code>整个表。第二URI表示指定Id的书名，第三个表示指定id的书名的首单词。</p>

<p>那么，
<code>books/12/title</code>将匹配第二个，在<code>Content Provider</code>收到这个<code>URI</code>时，可以使用<code>UriMatcher</code>得到2。
UriMatcher为URI提供了两种通配符 <code>#</code>代表数字；<code>*</code>代表任意字符。</p>

<p><strong>需要注意一点的是</strong>，<code>UriMatcher</code>进行匹配，会受到<code>addURI</code>的先后顺序影响。</p>

<p>如：<code>uriMatcher</code>按以下顺序添加：</p>

<pre><code>*/#
#/*
</code></pre>

<p>那么 <code>9/title</code>将不能获得匹配，是不是很奇怪？</p>

<pre><code>*/#/#
*/*/*
</code></pre>

<p> <code>books/10/title</code>也不能被匹配。</p>

<p>在匹配PATH是挨个参数进行，一旦一个路径参数被匹配，那么它就不会更换。
以<code>books/10/title</code>来说，匹配第一个patten的第一个参数 * 通过，10 匹配 <code>#</code>也通过，title不能匹配#，那么此时进行第二个patten的匹配。那么第二个patten必须满足<code>*/#</code>开头，否则就算是 <code>*/*</code>也不能通过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码(二)之JsonReader和JsonWriter]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li/"/>
    <updated>2015-01-10T14:17:21+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/10/gsonyuan-ma-zhi-streamchu-li</id>
    <content type="html"><![CDATA[<p>前文介绍了<code>Gson</code>对于<code>Json</code>规范中的类型进行了抽象定义，本文将来介绍<code>stream</code>包中的源码，这一块是<code>Gson</code>的核心代码之一。Gson中的JsonReader和JsonWriter抄自android.util包中的两个类，只是把其中的上下文栈由ArrayList换成了数组，提高了效率。这两个类为Json序列化和反序列化提供了基本接口。</p>

<!--more-->


<h1>反序列化&mdash;JsonReader</h1>

<h2>StringPool&ndash;(Flyweight Pattern)</h2>

<p>在Stream包中提供了一种针对String的优化处理，可以减少内存中String对象的个数，途径就是通过StringPool来对字符串进行复用。需要注意的是，在Java中字符串对象是不能被修改的，这也是这个Pool能正常工作的重要原因。StringPool原理和HashMap一模一样，通过一个2的n次方(512)作为数组的长度，字符串的hascode计算方式和String中的一致。为了使得hashcode分布分散一点，同样使用hashmap的补偿hash函数对hashcode进行处理，这一块的具体优化处理可以关注以后的HashMap源码分析。</p>

<h2>深度优先的解析策略</h2>

<p>Gson解析Json字符采用的是深度优先策略，下面是一个简单解析的栗子：</p>

<pre><code>[
&lt;!--数组中每一个对象为一个message对象--&gt;
{
  "id": 912345678901,
  "text": "How do I read a JSON stream in Java?",
  &lt;!--geo是一个double类型的数组--&gt;
  "geo": null,
  &lt;!--user对象--&gt;
  "user": {
    "name": "json_newb",
    "followers_count": 41
   }
},
{
  "id": 912345678902,
  "text": "@json_newb just use JsonReader!",
  "geo": [50.454722, -104.606667],
  "user": {
    "name": "jesse",
    "followers_count": 2
  }
}
]
</code></pre>

<p>深度解析的逻辑如下，先找到这个json字符串的开始位置，本例中是<code>[</code>，此时我们知道这个json字符串是一个数组，下一步从第一个元素开始解析(一层循环)。读取下一个字符，<code>{</code>,可以知道第一个元素为对象。对于<code>{</code>开始的JsonObject，我们知道它其中的内容肯定是键值对的样式，那我可以读取下一个字符，而且它必须为<code>"</code>(属性名)，然后去读取属性值。ok，我们可以看到这是一种非常正常的解析逻辑，其实Gson的解析就是这么做的。</p>

<h2>数据抽象</h2>

<p>为了进行上面的解析过程，Gson中定义了两种数据类型：</p>

<h3>JsonToken(解析类型)</h3>

<p>由于Json定义规范的原因，我们在解析过程中只要解析到一个结构的第一个元素再联系上下文就可以推断这个结构的类型。JsonToken用来描述<code>Json</code>中的<code>'{','}','[',']','"'</code>,<code>NULL</code>,<code>number</code>，<code>boolean</code>,属性名和属性字符串值，其实JsonToken的基本上等于每一个结构的开头，其中<code>"</code>既可以表示一个属性名也可以表示一个属性就是一个String，这需要按照上下文来确定。
在<code>JsonReader</code>定义了一个属性<code>token</code>，用来存储<code>Json</code>串解析位置的下一个<code>JsonToken</code>。</p>

<h3>JsonScope(解析上下文)</h3>

<p>用来描述当前正在解析的位置所处的一个状态，为解析提供一个上下文做推断。比如，目前我们解析到了一个<code>{</code>字符，那么下一个字符串必须是空或者&#8217;&ldquo;&lsquo;，如此我们可以推断这个<code>"</code>肯定是一个JsonToken.Name(属性名)。此外，JsonScope还可以描述一个JsonArray或者JsonObject目前解析到的位置是否是第一个元素。<code>JsonScope</code>被存放在一个栈中，而且是成对出现。</p>

<pre><code> private JsonScope[] stack = new JsonScope[32];
 {
   push(JsonScope.EMPTY_DOCUMENT);  //静态初始化时push空Json文件到栈顶
 }
 需要注意的是，这里这个栈之只实现了一个push操作，并提供了动态增长，出栈操作只需要简单的简单的stacksize--
</code></pre>

<h2>JsonReader工作流</h2>

<p><code>JsonReader</code>的构造函数接受一个<code>Reader</code>的参数，它是一个<code>Json</code>串的<code>InputStream</code>包装出来的<code>Reader</code>。</p>

<p>对于这个上文<code>Json</code>文档的解析，<code>JsonReader</code>的理逻辑如下：</p>

<pre><code>List&lt;Message&gt; result = new ArrayList&lt;Message&gt;(); 
jsonReader.beginArray();   //找到数组
while(jsonReader.hasnext) {
    Message message = new Message();
    jsonReader.beginObject();   //开始数组中的对象
    while(jsonReader.hasnext) {
        String name = jsonReader.nextName();
        if(name.equals("id")) {
            message.setId(jsonReader.nextString());
        }else if(name.equals("text")) {
            message.setText(jsonReader.nextString());
        }else if(name.equals("geo")&amp;&amp;jsonReader.peek()!=NULL) {
             List&lt;Double&gt; list = new ArrayList&lt;Double&gt;();
             jsonReader.beginArray();
             while(jsonReader.hasnext()) {
                list.add(jsonReader.nextDouble());
             }
             JsonReader.endArray();
        }
        jsonReader.beginObject();
       .....开始解析User对象......
    }
    result.add(message);
}
</code></pre>

<h3>一些函数的解释</h3>

<h4>begin和 end系列函数</h4>

<p>其实这两个函数只是从业务的角度出发，封装了一下，实际两个函数都是调用<code>except(JsonToken)</code>，作用是寻找<code>json</code>字符串中的下一个<code>JsonToken</code>。以<code>beginObject()</code>函数来说，它直接调用<code>except(JsonToken.BEGIN_OBJECT)</code>。</p>

<pre><code>private void expect(JsonToken expected) throws IOException {
peek();         //找到下一个JsonToken，赋值给JsonReader的token属性
if (token != expected) {  //判断下一个Token是否等于指定的Token类型
  throw new IllegalStateException("Expected " + expected + " but was " +        peek() + " at line " + getLineNumber() + " column " +       getColumnNumber());
}
advance();  //下一步操作
}
</code></pre>

<h4>peek函数</h4>

<p>peek函数是JsonReader中最重要的函数，它的主要作用是进行上下文的判断，判断下一个JsonToken的读取方法。</p>

<p>下面看一下<code>peek()</code>函数的实现：</p>

<pre><code>public JsonToken peek() throws IOException {
//之前解析出来的token还没有被消费，直接取回
if (token != null) {
  return token;
}
//查看栈顶的JsonScope，这里可以看到JsonScope就是一个上下文的角色
switch (stack[stackSize - 1]) {
case EMPTY_DOCUMENT:    //json文档的开始 
  if (lenient) {    //json防止攻击引入的前导，防止跨域攻击
    consumeNonExecutePrefix();
  }
  stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;   //注意这里不是push而是直接替换栈顶元素
  JsonToken firstToken = nextValue();   //返回流中的下一个开始JsonToken，在上个例子中就是'['，也就是这里返回的是一个JsonToken.BEGIN_ARRAY,这个值还会被保存在token属性中
  if (!lenient &amp;&amp; token != JsonToken.BEGIN_ARRAY &amp;&amp; token != JsonToken.BEGIN_OBJECT) {   //一个json文档开始无非就是一个对象或者数组
    throw new IOException("Expected JSON document to start with '[' or '{' but was " + token
        + " at line " + getLineNumber() + " column " + getColumnNumber());
  }
  return firstToken;
case EMPTY_ARRAY:
    //目前处于一个数组中，但是还没有开始读取任何数据
  return nextInArray(true);
case NONEMPTY_ARRAY:
  return nextInArray(false);
case EMPTY_OBJECT: //目前处于一个JsonObject中但是还没有读取任何数据
  return nextInObject(true);
case DANGLING_NAME: //目前处于一个属性名的位置
  return objectValue();
case NONEMPTY_OBJECT:
  return nextInObject(false);
case NONEMPTY_DOCUMENT:
    //当前处于一个文档的解析上下文中，可以理解为根元素下一级的环境
  int c = nextNonWhitespace(false);
  if (c == -1) {
    return JsonToken.END_DOCUMENT;
  }
  pos--;
  if (!lenient) {
    throw syntaxError("Expected EOF");
  }
  //找下一个JsonToken
  return nextValue();
case CLOSED:
  throw new IllegalStateException("JsonReader is closed");
default:
  throw new AssertionError();
}
}
</code></pre>

<h4>nextIn**()</h4>

<p> 提供了数组、JsonObject的解析方法。</p>

<h4>nextValue()</h4>

<pre><code>找下一个JsonToken

private JsonToken nextValue() throws IOException {
int c = nextNonWhitespace(true);    //找到当前解析位置之后的第一个非空白字符
switch (c) {
case '{':
  push(JsonScope.EMPTY_OBJECT);   //进入一个JsonObject
  return token = JsonToken.BEGIN_OBJECT;

case '[':
  push(JsonScope.EMPTY_ARRAY);   //进入一个数组
  return token = JsonToken.BEGIN_ARRAY;
  //以上两种情况说明是一个新的结构的开始，所以需要pushJsonScope到栈中
case '\'':
  checkLenient(); // fall-through
case '"':
  //代表一个Json字符串值
  value = nextString((char) c);  //找到两个引号之间的String值
  return token = JsonToken.STRING;

default:
  pos--;
  return readLiteral();
}
}
</code></pre>

<h3>JsonReader总结</h3>

<p>JsonReader可以看作一个最基本的Json解析的接口，JsonReader中通过一个上下文来保存当前解析的环境，通过next**系列函数来获取下一个JsonToken。</p>

<h1>序列化&ndash;JsonWriter</h1>

<p>理解了JsonReader的源码之后，再来看Writer就相对来说简单多了。现在我们有一个数组，List<Message>，它的值就如上面的例子，那如何序列化呢?</p>

<pre><code>public void writeJsonStream(OutputStream out, List&lt;Message&gt; messages) throws IOException {
      JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
      writer.setIndent("\t");           //设置每一行的缩进
      writeMessagesArray(writer, messages);
      writer.close();
    }

    public void writeMessagesArray(JsonWriter writer, List&lt;Message&gt; messages) throws IOException {
      writer.beginArray();   //[
      for (Message message : messages) {
        writeMessage(writer, message);
      }
      writer.endArray();
    }

    public void writeMessage(JsonWriter writer, Message message) throws IOException {
      writer.beginObject(); //{
      writer.name("id").value(message.getId()); // "id":23435356
      writer.name("text").value(message.getText()); //"text":"dflsfldsfljd"
      if (message.getGeo() != null) {
        writer.name("geo");
        writeDoublesArray(writer, message.getGeo());
      } else {
        writer.name("geo").nullValue();
      }
      writer.name("user");
      writeUser(writer, message.getUser());
      writer.endObject();
    }

    public void writeUser(JsonWriter writer, User user) throws IOException {
      writer.beginObject();
      writer.name("name").value(user.getName());
      writer.name("followers_count").value(user.getFollowersCount());
      writer.endObject();
    }

    public void writeDoublesArray(JsonWriter writer, List&lt;Double&gt; doubles) throws IOException {
      writer.beginArray();
      for (Double value : doubles) {
        writer.value(value);
      }
      writer.endArray();
    }
</code></pre>

<h2>JsonWriter中的函数</h2>

<p>   事实上，可以看到JsonWriter的工作和JsonReader刚好相反，两个类的对json字符串的处理方式也基本相同。下面说一些业务流程中较为重要的方法。</p>

<h3>beginArray and beginObject</h3>

<p>开始向流中写入一个数组或者JsonObject的开始，注意，这里不仅仅是写入一个<code>[</code>或者一个<code>{</code>这么简单，首先会调用<code>writeDeferredName</code>方法，它的主要功能是如果这个开始的JsonElement是JsonObject中的一个属性，那么它的前面肯定有一个和上一个元素的分割符号和一个名字。</p>

<h3>endArray and endObject</h3>

<p>结束一个数组和对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson源码分析(一)之Json结构抽象和注解使用]]></title>
    <link href="http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi/"/>
    <updated>2015-01-06T22:31:27+08:00</updated>
    <id>http://chuyun923.github.io/blog/2015/01/06/gsonyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<p>XML和Json作为最常用的两种网络传输格式而被广泛使用，XML在早期数据传输中作为首选，但是近年来Json以其轻量级和更容易编写和解析而越来越流行，Gson作为google的一个开源Json解析框架提供了稳定和快速解析的功能，可以读读它的源代码了解一番。</p>

<!--more-->


<p>说到Gson，其实它无非就是做两个工作，序列化(Object&mdash;>JsonString)和反序列化(JsonString&mdash;>Object)，后文所说的<em>两个方向</em>从Object到String和String到Object的两个方向。可想而知，对于序列化来说，是较为容易的工作，而对于反序列化即Json解析才是Gson的重头戏。既然是对Json字符串的解析，那么少不了对Json字符串中的结构进行抽象。</p>

<h2>Json抽象类</h2>

<h3>JsonElement</h3>

<p>这是Json中元素的基类，它只提供了若干个类型判断的接口，简单判断这个Json元素的类型。以下几个类型都是它的子类。</p>

<h4>1、JsonObject</h4>

<p>包含多个JsonElement的集合，它在Json中对应这种类型的数据：</p>

<pre><code>{
    "count":100,
    "users":[],
    "paging":{
        "offset":0,
        "limit":10,
        "hasMore":true
    }
}
</code></pre>

<p>这个data是一个典型的JsonObject，它以<code>{</code>开头，其中包含了一些类似数值，数组，对象等其他JsonElement的内容。<strong>其实每一个Json字符串的根节点都是一个JsonObject或者JsonArray。</strong></p>

<p>JsonObject提供了比较多的方法来得到Json中的信息，addProperty()函数可以在当前Json节点下新建子结点。</p>

<h4>2、JsonArray</h4>

<p>JsonArray也表示JsonElement的集合，注意：<strong>Json中的数组并不要求所有的数据类型都一样</strong>。</p>

<pre><code>    [true,"hello"] //JsonArray,包括一个boolean和一个hello类型。
</code></pre>

<p>需要讨论的是JsonArray和JsonObject的区别是什么？从集合的角度来说，JsonObject中的JsonElement是无序的，而JsonArray中的集合元素是有序的，从直观感受来说，你可以通过下标来引用JsonArray中的元素，而JsonObject是通过键值对的方式来访问的,<code>get("name")---&gt;value</code>。</p>

<h4>3、JsonPrimitive</h4>

<p>对应Json中的基本类型，比如boolean，int，当然提供了基本类型和包装类的自动替换。</p>

<pre><code>"count":100
</code></pre>

<h4>4、JsonNull</h4>

<p>空，对应null</p>

<pre><code>"person":null
</code></pre>

<p>以上就是Gson对应Json结构的封装。</p>

<h3>注解-Annotations</h3>

<h4>Expose</h4>

<p>在对象进行序列化和反序列化的过程中，我们可以通过注解来屏蔽某一些字段。这个注解默认有两个参数，<code>serialize</code>和<code>deserialize</code>都是默认true。如果设置为false，表示这个序列化(反)的过程中，这一个属性不需要进行处理。</p>

<p>通过Expose标注的属性在直接<code>new Gson()</code>的情况下不能生效，我们必须通过<code>Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>来创建一个可以识别Expose注解的Gson。</p>

<p>小小的吐槽一把，这个地方的使用确实不太方便，举个栗子，一般来说，我们进行序列化的时候都是希望某一个属性不会序列化到Json字符里面(反之亦然)，所以这里的一般思维是我要去处理这些特殊的属性。而如果你想通过Expose来去掉10个属性中的某一个，对不起，10个属性你都需要加上<code>@Expose</code>,然后对你想要处理的那个属性的Expose注解增加false参数，简直就是坑爹。。。。</p>

<pre><code>//我想让Person类在序列化时，不去序列化password，是不是很坑爹？
class Person {
    @Expose
    private String userName;
    @Expose (serialize = false)
    private String passWord;
}
</code></pre>

<p>此外，和java本身的序列化一样，如果一个属性设置为<code>transient</code>或者<code>static</code>,那么两个序列化的两个方向上都会屏蔽掉这个属性，虽然比Expose简单，但是不够灵活。</p>

<h4>SerializedName</h4>

<p>这个注解使用较多，它会改变两个方向上这个属性的名称，在序列化是，JsonElement的键值会被替换成这个名字；解析时，Json中键值为这个名字的JsonElement会赋值给被注解的属性。</p>

<pre><code>class Person {

@SerializedName(value = "A")
private int a ＝ 1;
private int b = 2;
}

//{"A":1,"b":2}  这个Json字符串和前面的Person等价
</code></pre>

<p>它使用场景最多的地方就是比如后端返回的json中的名称和我们定义的model类名称不一样时使用。</p>

<h4>Since 和 Until</h4>

<p>我们可以对我们的Model类进行序列化(两个方向)的版本控制，Since和Until刚好是两个相反的意义。</p>

<p>例子：</p>

<pre><code>class Person {
    @Since(value = 1.0)     //GsonBuilder指定版本要从1.0开始的Gson才能解析
    private int a = 1;

    @Until(value = 1.5)   //GsonBuilder指定版本到1.5的Gson都可以解析，超过了不能解析
    private int b = 2;
}
</code></pre>

<p>和Expose一样，要想Gson识别这两个注解，同样需要通过GsonBuilder.setVersion(double).create()来实现。</p>
]]></content>
  </entry>
  
</feed>
