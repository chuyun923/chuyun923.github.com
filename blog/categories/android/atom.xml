<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 楚云之南]]></title>
  <link href="http://chuyun923.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2014-12-15T11:11:42+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[geniousadapter,快速构建Adapter]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter/"/>
    <updated>2014-12-14T20:28:32+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chuyun923/ingenious-adapter"><strong>geniousadapter</strong></a><br/>
前面的话：本项目的原型是<a href="https://github.com/JoanZapata/base-adapter-helper">QuickAdapter</a>，它们的思路基本一致，但本项目的优势在于：</p>

<ul>
<li>支持AdapterView存在多个layout类型</li>
<li>可配置图片加载缓存库</li>
</ul>


<!--more-->


<p>在使用AdapterView时，我们需要使用Adapter来绑定数据源和AdapterView中的每一项数据。通常我们继承自BaseAdapter,然后重写四个方法：</p>

<pre><code>public int getCount()

public Object getItem(int position) 

public long getItemId(int position)

public View getView(int position, View convertView, ViewGroup parent) 
</code></pre>

<p>其中主要的逻辑实现在getView，这个方法主要完成两步操作：1、生成(或者从缓存中取出)当前item对应的ItemView；2、将数据和ItemView绑定。通常，由于AdapterView支持缓存机制(如ListView)，我们通过一个Holder来避免每一次getView重复的findViewById。</p>

<pre><code>private static class Holder {
    TextView tv_name;
    ImageView iv_avatar;
    .....
}

public View getView(int position, View convertView, ViewGroup parent) {
    Holder hodler = null;
    if(converView==null) {
        holder = new Holder();
         convertView = LayoutInflater.from(context)
            .inflate(layoutId, parent, false);
        holder.tv_name = (TextView) findViewById(R.id.tv_name);
        holder.iv_avatar = (ImageView) findViewById(R.id.iv_avatar);
        ...
        //下次就不需要findViewById了
        covertView.setTag(holder);
    }

    holder =(Holder) convertView.getTag();
    holder.tv_name.setText(***);
    holder.iv_avatar.set(***);
} 
</code></pre>

<p>以上就是BaseAdapter的典型用法，那么在项目里面的所有Adapter都存在Holder，并且都存在<code>holder.properties = (ViewType) findViewById(id)</code>的重复代码。可以想象一下，如果Holder中有比较多的属性，特别是如果一个AdapterView具有多个不同类型的layout，那么也需要多个不同Holder，getView将会特别复杂。<br />
<strong>geniousadapter</strong>对getView进行了一层封装，并将getView函数的两部分功能进行拆分，自动完成了生成ItemView和Holder的过程，通过一个抽象方法covert让子类实现数据绑定。子类需要实现两个抽象方法：</p>

<pre><code>  /**
  * 通过AdapterHolder填充view的属性,这个函数主要完成数据绑定的过程，使用方法：
  * holder.setText(R.id.tv_name,"张三").setText(R.id.tv_nickName,
  * "三儿").setImageResource(R.id.iv_avatar,R.drawable.ic_user_avatar);
  * holder 
  * item 当前item需要绑定的数据
  */
  protected abstract void convert(AdapterHolder holder, T item,int viewType);

 /**
  * layoutid至数据类型的映射,插入顺序对应itemviewtype
  * @return
  */
  protected abstract int[] assignLayoutIDs();
</code></pre>

<p><code>holder.setImageUrl(int,imageUrl)</code>可以通过使用者自己定义远程图片加载的方式。用户可以自己实现加载图片或者使用第三方图片加载缓存库，其接口如下：</p>

<pre><code>public interface ImageLoader {

public void load(ImageView imageView,String imageUrl);

//placeResId  默认图resid
public void load(ImageView imageView,String imageUrl,int placeResId);
}
</code></pre>

<p>比如我们可以使用picasso来完成加载图片的功能，在合适的位置来指定：</p>

<pre><code>DefaultAdapterConfig.setImageLoader(new ImageLoader() {
    @Override
    public void load(ImageView imageView, String imageUrl) {
        picasso.load(imageUrl).into(imageView);
    }

    @Override
    public void load(ImageView imageView, String imageUrl, int placeResId) {
        picasso.load(imageUrl).placeholder(placeResId).into(imageView);
    }
});
</code></pre>

<p>总结：genious Adapter可以使用户在getView方法中无需关注每一项ItemView生成的细节，而只需要处理数据绑定的逻辑即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
</feed>
