<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 楚云之南]]></title>
  <link href="http://chuyun923.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://chuyun923.github.io/"/>
  <updated>2014-12-30T22:27:06+08:00</updated>
  <id>http://chuyun923.github.io/</id>
  <author>
    <name><![CDATA[楚云]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android ActionBar]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/23/android-actionbar/"/>
    <updated>2014-12-23T10:58:00+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/23/android-actionbar</id>
    <content type="html"><![CDATA[<h1>Android之ActionBar</h1>

<p>ActionBar作为Android3.0系统引入的一个重要的android app的风格，了解它的使用方法是每一个android开发者都必须要掌握的，本文主要基于android官方文档，对一些不常用的内容进行了删减，整理而成。</p>

<!--more-->


<p>说起3.0以后的ActionBar，其实在做3.0以前开发的童鞋应该有印象，Android提供了一个TitleBar，只不过默认的TitleBar只能显示一个标题和一个图标。它的样子大概如下：<br />
<img src="http://androidpeople.files.wordpress.com/2009/12/withicon.jpg" alt="" /></p>

<p>如果需要自己定义一个更加炫酷的Titlebar,比较麻烦，可以参考这篇文章：<a href="http://www.cnblogs.com/a284628487/archive/2013/06/07/3125265.html"><strong>自定义TitleBar</strong></a></p>

<p>ActionBar是TitleBar的增强版本，主要包括四个部分：</p>

<ol>
<li>为app提供一个唯一图片标识和导航的button,如果当前页面不是应用的首页，应该在app icon的左边添加返回的剪头。</li>
<li>切换界面上显示的view，官方名称叫view control。</li>
<li>放置一些显式的按钮，长按会显示它的title</li>
<li>放置一个action overflow</li>
</ol>


<p>对应如下图片：</p>

<p><img src="https://developer.android.com/design/media/action_bar_basics.png" alt="" /></p>

<p>正常的ActionBar会占据一定的屏幕空间，在ActionBar显示或者隐藏时，屏幕中的数据都会重绘去适应。如果我们需要ActionBar浮动在内容上面，可以将<code>windowActionBarOverlay</code>属性设置为true。</p>

<h2>增加ActionBar的Item</h2>

<p>在android菜单中曾经提到如何在ActionBar中增加菜单项，这里不再赘述。这里补充一个小的case：</p>

<p> 在ActionBar上显示的item也可以同时显示icon和title，当然前提是ActionBar的空间富余。通过在showAsAction中增加withText。</p>

<h2>分离的ActionBar(split)</h2>

<p>在分辨率不大的设备上，如果有足够多的Item需要显示，可能面临着屏幕宽度不够而显示不了那么多的Icon。分离ActionBar中的logo和菜单项，将菜单项移动到屏幕的下面，如图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-splitaction@2x.png" alt="" /></p>

<p>如果需要系统处理，那么我们需要指定属性：<code>uiOptions="splitActionBarWhenNarrow"</code>，但是如果需要支持低版本，我们可以这样写：</p>

<pre><code>    &lt;manifest ...&gt;
        &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
            &lt;meta-data android:name="android.support.UI_OPTIONS"
               android:value="splitActionBarWhenNarrow" /&gt;
        &lt;/activity&gt;
    &lt;/manifest&gt;
</code></pre>

<h2>ActionBar的导航button</h2>

<p>如果设置ActionBar.setDisplayHomeAsUpEnable(true),会产生一个导航按钮，如图所示：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-up.png" alt="" /></p>

<p>这个按钮和系统的back按键的区别在于，系统的back键有时候仅仅是为了返回到屏幕的上一次状态，而点击这个导航键就会返回到上一次的界面。
如果仅仅set这个导航键可见，它并不会响应任何操作，我们需要手动去指定点击这个导航键将会打开那个Activity，有两种方法可以来指定：</p>

<ol>
<li>在Menifest文件中通过activity的parentActivityname属性指定，当然这个属性是4.1加入的，如果要兼容之前的版本，可以通过meta的方式来做到。</li>
<li>在Activity中复写getParentActivityIntent，可以指定在app内导航的Intent。在别的应用中打开app，可以通过复写onCreateNavigateUpTaskStack来实现。</li>
</ol>


<p>注意，在support v7包中的actionbarActivity中，对以上提供了默认实现。</p>

<h2>ActionView</h2>

<p>actionview是在点击action button之后，一个显示出来的交互view,如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-searchview@2x.png" alt="" /></p>

<p>可以通过Menu item的<code>actionViewClass</code>来指定一个widget。我们也可以直接自己指定一个自定义布局给Action button，只需要把layout的id赋值给<code>actionLayout</code>即可。</p>

<p>app要获取这个Action View中的一些事件，可以在onCreateOptionsMenu中通过<code>menuItem.getActionView()</code>来获得。</p>

<p>下面来说一个比较有意思的可折叠的actionview，前文可知，如果设置actionLayout，那么如果ActionBar上面空间足够时，会直接把这个自定义的layout显示出来，但是如果这个item被放到overflow里面去了呢？此时<code>showAction</code>中的一个属性<code>collapseActionView</code>的作用就会显示出来，这个属性的作用是：</p>

<p>如果这个action button被放到overflow中，点击后还是可以把它的actionview打开(可折叠)，如果不加这个属性，那么系统将不会打开actionview。如果是打开折叠的actionview，ActionBar会自动把导航剪头加上，并且清空ActionBar上面的action button(除去overflow按钮)，如下图：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/CSU-PL/637624/o_5B4AFB05-1AFC-4F4F-887F-304187E96E16.png" alt="" /></p>

<p>我们可以在<code>onCreateOptionsMenu</code>中  通过<code>MenuItemCompat.setOnActionExpandListener</code>来监听actionview的扩张事件。</p>

<h2>Action Provider</h2>

<p>上一节提到的actionview，它是直接在ActionBar上面展示出来，ActionProvider是在ActionBar上展示一个下拉的菜单，如下图：</p>

<p><img src="https://developer.android.com/images/ui/actionbar-shareaction@2x.png" alt="" /></p>

<p>创建一个Action provider可以通过指定给<code>android:actionProviderClass</code>属性一个ActionProvider即可。</p>

<h2>添加导航的tab</h2>

<p>这种方式已经不被推荐使用了，所以这里不做详细解释，使用它很简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android之菜单]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan/"/>
    <updated>2014-12-19T17:19:36+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/19/androidzhi-cai-dan</id>
    <content type="html"><![CDATA[<p>本文参考自官方文档：<a href="https://developer.android.com/guide/topics/ui/menus.html">https://developer.android.com/guide/topics/ui/menus.html</a></p>

<p>Android为了维护app之间一个统一的操作习惯，提供了Menus来处理用户和Activity之间的一些交互。但是在不同的系统版本上面推荐的Menu不一样。比如在android 3.0以下，由于Google会要求所有设备生产商提供一个菜单的实体键，所以在3.0一下菜单的主要弹出方式就是点击菜单实体键，弹出6个条目的菜单面板。在3.0以后，引入ActionBar，打开菜单行为转变成点击ActionBar上面的overflow按钮。这两种菜单面板的操作一般都是影响到整个app的操作。</p>

<!--more-->


<p>下图是3.0一下的Option Menu的样子：<br /></p>

<p><img src="https://developer.android.com/images/options_menu.png" alt="" /></p>

<p>这是3.0上的ActionBar的样子：</p>

<p><img src="https://developer.android.com/images/ui/actionbar.png" alt="" /></p>

<p>当然除了上面提到的菜单面板，Android还提供了上下文菜单(Context menu)和弹出菜单(Popup Menu)。尽管存在三种不同的菜单，但是Android提供了一个统一操作的API。</p>

<h2>在XML中定义菜单项</h2>

<p>Menu文件定义的位置在 res/menu目录下，而且顶层元素必须是Menu。在Menu中可以放置item和group，其中group又可以包含多个item。在group中的所有item都会共享某一些熟悉，主要是用来对group进行分类管理,比如设置某一类菜单项的可见。</p>

<p>多级菜单可以通过在item中嵌入Menu来现实。</p>

<h3>选项菜单</h3>

<p>前面已经说到，选项菜单在3.0前后版本存在一些差别。在Fragment和Activity中都可以创建选项菜单,系统会首先显示Activity中创建的item，然后按照fragment加入的顺序添加item。<strong>在3.0一下时，onCreateOptionsMenu是在点击菜单键时触发；在3.0以上，则是在Activity创建时就会调用。</strong></p>

<p>响应点击事件，可以在onOptionsItemSelected中进行。注意这个事件处理函数需要返回一个boolean值。如果已经处理了这次点击需要返回true，否则直接调用super.onOptionsItemSelected()(返回fasle)。这个事件的处理流程是，事件先被送到Activity，然后按照先进先达的顺序，直至莫一个fragement处理了这次点击或者所有的fragment都已经遍历了。</p>

<p>可以在菜单的item中指定<code>android:onClick</code>，这个点击事件的处理函数必须是Activity中签名为public 并且接受一个MenuItem的参数。</p>

<p><strong>更新菜单中的选项</strong>，我们可以通过onCreateOptionsMenu来创建菜单项，但是如果想在运行时改变菜单中的选项，可以重写onPrepareOptionsMenu方法来实现。在3.0以下，这个方法会在菜单键每次按下的时候触发；在3.0以上，由于ActionBar是一直显示的，所以我们如果需要改变菜单，可以主动调用<code>invalidateOptionsMenu()</code>,然后系统会去走onPrepareOptionsMenu。</p>

<h3>上下文菜单</h3>

<p>Contextual Menu主要多用于和界面特别是AdapterView中的某一个item进行交互,通过长按控件来呼出一个Action Menu。如果说Option menu(Actionbar)上面的菜单选项是针对整个app的范围，那么Contextual Menu从名字就可以看出来是针对当前context范围内的操作。存在两种方式：</p>

<ul>
<li>floating context menu，通常在长按ListView中的某一项之后出现。</li>
<li>Contextual action mode，会显示出一个ActionBar，它是一种ActionMode的实现，在3.0系统以上才能使用。</li>
</ul>


<p>下图左边是floating context Menu，右边是Contextual action mode</p>

<p><img src="https://developer.android.com/images/ui/menu-context.png" alt="" /></p>

<h4>floating context menu</h4>

<p>floating context menu是3.0一下版本建议使用的，针对当前Context的一个操作面板，通过长按指定控件呼出。<strong>长按事件如果也被监听，那么会先执行长按事件，再执行onContextItemSelected。如果长按事件处理返回true，那么context Menu不会被呼出</strong>：</p>

<ol>
<li>通过Activity或者Fragment的registerForContextMenu,传入一个View，为它注册一个floating context menu</li>
<li>实现onCreateContextMenu，来创建Menu条目</li>
<li>实现onContextItemSelected处理选择某一个菜单的事件</li>
</ol>


<p>同样需要注意的是在处理事件时，也是由Activity最先接收，然后按照加入顺序分发到每一个Fragment。</p>

<h4>contextual action mode</h4>

<p>从上图可以看到Contextual action和ActionBar颇有几分相似，但是两者直接并无直接关联。在3.0一下版本中，我们需要使用support包中的兼容方案。
单个View使用步骤如下：</p>

<ol>
<li>实现ActionMode.CallBack，这里主要实现action mode的主要逻辑</li>
<li>在合适的时候通过Activity或者fragment的startSupportActionMode来进入一个contextaul action mode。</li>
</ol>


<p>在AdapterView中使用，步骤如下：</p>

<ol>
<li>实现AbsListView.MultiChoiceModeListener，其实这个玩意继承自ActionMode.CallBack，增加了onItemCheckedStateChanged函数，用来处理当AbsListView中某一项的选择状态改变时的操作。</li>
<li>通过设置AbsListView的MultiChoiceModeListener，注意，这里默认进入Action Mode的动作是长按某一个Item。</li>
</ol>


<h3>Popup Menu</h3>

<p>API level 11加入。在android中还提供了一种用来相对于界面上已经存在的一个控件的菜单，比如类似于ActionBar上面的overflow。</p>

<p><img src="https://developer.android.com/images/ui/popupmenu.png" alt="" /></p>

<p>使用Popup Menu的步骤如下：</p>

<ol>
<li>通过context和相对的View创建PopupMenu对象。</li>
<li>通过popupMenu对象来设置Menu的布局和监听事件函数。</li>
</ol>


<p><strong>需要注意的是PopupMenu弹出的位置是自适应的，主要看这个View在那个地方有空间，就会在哪个方向上面弹出来。</strong></p>

<h3>选择菜单项</h3>

<p>选择菜单和前面所提及的菜单类型不同，它仅仅是一种菜单项的表现形式。在本文之前提及的所有菜单中，每一个菜单项的呈现方式都是简单的文字(或者icon),如果我们要加入一种单选框或者复选框的效果，可以使用item的checkable属性。效果如下图：</p>

<p><img src="https://developer.android.com/images/radio_buttons.png" alt="" /></p>

<p>需要注意的是，在option Menu中，如果一个菜单项是以icon的方式显示出来，那么它将不会显示选择框。</p>

<p>我们亦可以通过group来为一组item设置选择条件，这才是它本来的意义。<code>android:checkableBehavior</code>可以设置成radio 或者checkbox或者none，默认应该是checkbox。
<strong>选择菜单项是不能保存状态的，如果app退出，下次再进入状态就不存在了。</strong></p>

<h3>意图菜单项</h3>

<p>如果我们需要在菜单项中通过Intent启动另外一个Activity，Menu提供了专门的类型来处理，这就是Intent Options。而且意图菜单项还可以在系统中解析这个Intent是否能够被Activity了解，如果系统中没有Activity能够接受这个Intent，那么这个意图菜单项将不会展示出来。使用步骤如下：</p>

<ol>
<li>在定义的Intent中增加一个category：<code>CATEGORY_ALTERNATIVE and/or CATEGORY_SELECTED_ALTERNATIVE</code></li>
<li>调用Menu.addIntentOpions()。</li>
</ol>


<p>addIntentOptions方法返回增加的item数目，所以通过Intent解析的item都会被加入菜单中。<strong>这个菜单项的item title就是intent-filter的android:label,icon是application icon</strong></p>

<p>感觉这个东东和settings等系统模块一样，在中国开发者的眼中根本不会去用它，所以老外才会感叹中国做的app怎么这么难用，每个应用的风格都不一样。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[geniousadapter,快速构建Adapter]]></title>
    <link href="http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter/"/>
    <updated>2014-12-14T20:28:32+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/12/14/geniousadapter-kuai-su-gou-jian-adapter</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chuyun923/ingenious-adapter"><strong>geniousadapter</strong></a><br/>
前面的话：本项目的原型是<a href="https://github.com/JoanZapata/base-adapter-helper">QuickAdapter</a>，它们的思路基本一致，但本项目的优势在于：</p>

<ul>
<li>支持AdapterView存在多个layout类型</li>
<li>可配置图片加载缓存库</li>
</ul>


<!--more-->


<p>在使用AdapterView时，我们需要使用Adapter来绑定数据源和AdapterView中的每一项数据。通常我们继承自BaseAdapter,然后重写四个方法：</p>

<pre><code>public int getCount()

public Object getItem(int position) 

public long getItemId(int position)

public View getView(int position, View convertView, ViewGroup parent) 
</code></pre>

<p>其中主要的逻辑实现在getView，这个方法主要完成两步操作：1、生成(或者从缓存中取出)当前item对应的ItemView；2、将数据和ItemView绑定。通常，由于AdapterView支持缓存机制(如ListView)，我们通过一个Holder来避免每一次getView重复的findViewById。</p>

<pre><code>private static class Holder {
    TextView tv_name;
    ImageView iv_avatar;
    .....
}

public View getView(int position, View convertView, ViewGroup parent) {
    Holder hodler = null;
    if(converView==null) {
        holder = new Holder();
         convertView = LayoutInflater.from(context)
            .inflate(layoutId, parent, false);
        holder.tv_name = (TextView) findViewById(R.id.tv_name);
        holder.iv_avatar = (ImageView) findViewById(R.id.iv_avatar);
        ...
        //下次就不需要findViewById了
        covertView.setTag(holder);
    }

    holder =(Holder) convertView.getTag();
    holder.tv_name.setText(***);
    holder.iv_avatar.set(***);
} 
</code></pre>

<p>以上就是BaseAdapter的典型用法，那么在项目里面的所有Adapter都存在Holder，并且都存在<code>holder.properties = (ViewType) findViewById(id)</code>的重复代码。可以想象一下，如果Holder中有比较多的属性，特别是如果一个AdapterView具有多个不同类型的layout，那么也需要多个不同Holder，getView将会特别复杂。<br />
<strong>geniousadapter</strong>对getView进行了一层封装，并将getView函数的两部分功能进行拆分，自动完成了生成ItemView和Holder的过程，通过一个抽象方法covert让子类实现数据绑定。子类需要实现两个抽象方法：</p>

<pre><code>  /**
  * 通过AdapterHolder填充view的属性,这个函数主要完成数据绑定的过程，使用方法：
  * holder.setText(R.id.tv_name,"张三").setText(R.id.tv_nickName,
  * "三儿").setImageResource(R.id.iv_avatar,R.drawable.ic_user_avatar);
  * holder 
  * item 当前item需要绑定的数据
  */
  protected abstract void convert(AdapterHolder holder, T item,int viewType);

 /**
  * layoutid至数据类型的映射,插入顺序对应itemviewtype
  * @return
  */
  protected abstract int[] assignLayoutIDs();
</code></pre>

<p><code>holder.setImageUrl(int,imageUrl)</code>可以通过使用者自己定义远程图片加载的方式。用户可以自己实现加载图片或者使用第三方图片加载缓存库，其接口如下：</p>

<pre><code>public interface ImageLoader {

public void load(ImageView imageView,String imageUrl);

//placeResId  默认图resid
public void load(ImageView imageView,String imageUrl,int placeResId);
}
</code></pre>

<p>比如我们可以使用picasso来完成加载图片的功能，在合适的位置来指定：</p>

<pre><code>DefaultAdapterConfig.setImageLoader(new ImageLoader() {
    @Override
    public void load(ImageView imageView, String imageUrl) {
        picasso.load(imageUrl).into(imageView);
    }

    @Override
    public void load(ImageView imageView, String imageUrl, int placeResId) {
        picasso.load(imageUrl).placeholder(placeResId).into(imageView);
    }
});
</code></pre>

<p>总结：genious Adapter可以使用户在getView方法中无需关注每一项ItemView生成的细节，而只需要处理数据绑定的逻辑即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android构建内测版本程序]]></title>
    <link href="http://chuyun923.github.io/blog/2014/11/25/Android%E6%9E%84%E5%BB%BA%E5%86%85%E6%B5%8B%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <updated>2014-11-25T16:21:04+08:00</updated>
    <id>http://chuyun923.github.io/blog/2014/11/25/Android构建内测版本程序</id>
    <content type="html"><![CDATA[<p>在开发应用的过程中，有时候需要比较当前线上版本和正在开发中的版本差异，目前的做法只能是在两个不同的设备上面安装线上版本和开发中的版本，因为当前版本在调试过程中会覆盖旧版本。本文通过使用gradle来构建android应用变种版本，通过配置build type和productFlavors来进行实践，结果不完全尽如人意，但是提供了同一个程序不同变种在一个设备上共存的一种实践。</p>

<!--more-->


<h2>applicationID VS package</h2>

<p>在android的manifest文件中，我们可以配置一个package字段，这个字段主要有两个作用：</p>

<ol>
<li>作为包名指出当前应用的R文件所在路径和组件所在路径。所以我们在manifest文件中可以使用相对路径来配置activity等。</li>
<li>作为应用的唯一标识在系统中存在，此时，其作用==applicationID。</li>
</ol>


<p>要使同一个应用的不同版本在设备上共存的前提是它们具有不同的applicationID。</p>

<h2>buildTypes VS productFlavors</h2>

<p>要修改applicationId可以通过配置buildTypes中的applicationIdSuffix属性，起作用是将applicationId设置为package加上你所配置的后缀。此时，面临的第一个问题是我可能需要对debug版本和线上版本进行区分，比如不同的app图标，app名字以便在launcher里面进行区分。此时，productFlavor可以帮上忙，productFlavor提供了替换程序资源文件的功能，只需要在当前项目的src目录下新建一个flavor目录，在里面覆写资源即可。<br />到此，我们可以构建出一个用于开发的内测版本，它不会覆盖手机上已经安装的线上版本。</p>

<h2>一些尝试</h2>

<p>通过第二节，我们可以打出一个内测包，但是还是存在如下问题：</p>

<ol>
<li>两个版本中大部分的隐式跳转都一样，你能忍受在应用内随便点击一个页面，就会弹出选择框的情况？</li>
<li>如果应用中注册了Provider，将会被禁止安装第二个app，因为Provider不能重名</li>
</ol>


<p>针对第一个问题，我目前的解决方案是将actvity声明的data字段全部引用资源文件，然后通过flavor去为debug版本修改data中的implict_intent_host字段。</p>

<pre><code>    &lt;data android:host="@string/implict_intent_host"
         android:path="/movie"
         android:scheme="@string/implict_intent_scheme" /&gt;
</code></pre>

<p>这样，debug版本的activity的data将会改变，由于之前项目在创建隐式跳转都集中管理了，那么只需要修改创建的隐式intent  Uri的host部分从资源文件读取即可。但是这个方案存在一些问题：从第三方(如html5页面)的跳转就会失效，因为内测版本的intent host已经不再是公约的版本，这个暂时还没有解决方案来处理。。。，小小的遗憾</p>

<p>第二个问题好解决，只需要将provider的authorities字段区分一下即可，同样也会带来一点点问题，比如一个公司内部存在多个app，之间通过provider来提供数据的话，那么这个provider应该对于其它app是已知的，修改authorities之后，其他app会找不到这个provider。</p>

<h2>总结</h2>

<p>以上提到的方法虽然存在一些问题，但是从目前来看只要注意到之前提到的这些内容，应该不会给开发带来太大的困扰，同时我们最好提供一个默认的flovar，它不定义任何特殊的行为，那么通过gradle assembleNormalDebug和我们正常打出来的debug包没有任何差别。</p>
]]></content>
  </entry>
  
</feed>
